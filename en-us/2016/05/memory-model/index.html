<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What the HELL is MEMORY MODEL","datePublished":"2016-05-23T00:00:00Z","dateModified":"2016-05-23T00:00:00Z","author":{"@type":"Person","name":"Alex King","image":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.hljin.net\/en-us\/2016\/05\/memory-model\/"},"publisher":{"@type":"Organization","name":"Alex King's blog","logo":{"@type":"ImageObject","url":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"}},"description":" This article is translated from Chinese to English by ChatGPT. There might be errors.\nThis title looks as if I were capable of answering this question. In fact, I’m not; I’m miles away from being able to answer it. This article is only a summary of the material I’ve read so far and my own understanding of it, with absolutely no guarantee of accuracy.\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Alex King"><meta name=keywords content><meta name=description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This title looks as if I were capable of answering this question. In fact, I’m not; I’m miles away from being able to answer it. This article is only a summary of the material I’ve read so far and my own understanding of it, with absolutely no guarantee of accuracy."><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This title looks as if I were capable of answering this question. In fact, I’m not; I’m miles away from being able to answer it. This article is only a summary of the material I’ve read so far and my own understanding of it, with absolutely no guarantee of accuracy."><meta property="og:type" content="article"><meta property="og:title" content="What the HELL is MEMORY MODEL"><meta name=twitter:title content="What the HELL is MEMORY MODEL"><meta property="og:url" content="https://blog.hljin.net/en-us/2016/05/memory-model/"><meta property="twitter:url" content="https://blog.hljin.net/en-us/2016/05/memory-model/"><meta property="og:site_name" content="Alex King's blog"><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This title looks as if I were capable of answering this question. In fact, I’m not; I’m miles away from being able to answer it. This article is only a summary of the material I’ve read so far and my own understanding of it, with absolutely no guarantee of accuracy."><meta name=twitter:description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This title looks as if I were capable of answering this question. In fact, I’m not; I’m miles away from being able to answer it. This article is only a summary of the material I’ve read so far and my own understanding of it, with absolutely no guarantee of accuracy."><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2016-05-23T00:00:00"><meta property="article:modified_time" content="2016-05-23T00:00:00"><meta name=twitter:card content="summary"><meta property="og:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><meta property="twitter:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><title>What the HELL is MEMORY MODEL</title><link rel=icon href=https://blog.hljin.net/favicon.png><link rel=canonical href=https://blog.hljin.net/en-us/2016/05/memory-model/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://blog.hljin.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css><link rel=stylesheet href=https://blog.hljin.net/css/override.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://blog.hljin.net/en-us/ aria-label="Go to homepage">Alex King's blog</a></div><a class=header-right-picture href=https://blog.hljin.net/#about aria-label="Open the link: /#about"><img class=header-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://blog.hljin.net/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a><h4 class=sidebar-profile-name>Alex King</h4><h5 class=sidebar-profile-bio>Observing without evaluating is the highest form of human intelligence</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/archives title=Archives><i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden=true></i>
<span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/#about title=About><i class="sidebar-button-icon fas fa-lg fa-user" aria-hidden=true></i>
<span class=sidebar-button-desc>About</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/core2duoe6420 target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>What the HELL is MEMORY MODEL</h1><div class="postShorten-meta post-meta"><time datetime=2016-05-23T00:00:00Z>May 23, 2016</time></div></div><div class="post-content markdown"><div class=main-content-wrap><div class="alert warning"><p>This article is translated from Chinese to English by ChatGPT. There might be errors.</p></div><p>This title looks as if I were capable of answering this question. In fact, I’m not; I’m miles away from being able to answer it. This article is only a summary of the material I’ve read so far and my own understanding of it, with absolutely no guarantee of accuracy.</p><h2 id=out-of-order-execution>Out-of-order execution</h2><p>When a program runs, it does not execute strictly in the order written in the source code. Several factors can cause the actual execution order to differ from what we wrote:</p><ul><li>The compiler reorders code;</li><li>The CPU reorders instructions when executing (to optimize the pipeline, branch prediction, etc.);</li><li>Delays in cache coherence protocols lead to data inconsistencies between CPUs, whose symptoms look very similar to out-of-order execution (for this, see <a href=http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf>this article</a>, which introduces a simple cache system).</li></ul><p>Whether due to optimizations or cache issues, the resulting phenomenon is the same: in multithreaded programming, multiple processors simultaneously accessing shared variables can lead to counterintuitive results, producing effects that appear to contradict the execution order in the source code. The classic example is that operation A comes before operation B in the source code; now I observe that B has already happened, yet when I look at A I discover that A has not happened (interesting, it feels a bit like reading “In Search of Schrödinger’s Cat”).</p><p>This can also occur in hardware programming, and the essence is that multiple processors are reading and writing shared variables at the same time. Such nondeterministic behavior is not allowed (for a concrete example, see <a href=https://jfdube.wordpress.com/2012/03/08/understanding-memory-ordering/>this blog post</a>). The way to address the problem is the Memory Barrier.</p><h2 id=memory-barriers>Memory barriers</h2><p>Memory barriers are special instructions in the CPU instruction set. After executing such an instruction, the processor will, depending on the barrier type, synchronize memory and caches across CPUs, adjust pipeline branch prediction, and so on (wild guess, no guarantees), to ensure that instructions are executed in the order required by the programmer. Since processors on different architectures provide different instructions, memory barriers are roughly divided into the following four categories:</p><ul><li>Load-load barrier (<code>LoadLoad</code>): load operations before the barrier cannot be reordered to after load operations that come after the barrier;</li><li>Load-store barrier (<code>LoadStore</code>): load operations before the barrier cannot be reordered to after store operations that come after the barrier;</li><li>Store-store barrier (<code>StoreStore</code>): store operations before the barrier cannot be reordered to after store operations that come after the barrier;</li><li>Store-load barrier (<code>StoreLoad</code>): store operations before the barrier cannot be reordered to after load operations that come after the barrier;</li></ul><p>The instructions used by CPUs on different architectures do not necessarily have a one-to-one correspondence with the four types above. For example, the <code>lwsync</code> instruction on PowerPC provides the combined effects of <code>LoadLoad</code>, <code>LoadStore</code>, and <code>StoreStore</code> barriers. On the x86 processors we commonly use, normal memory accesses implicitly provide the effects of these three barrier types (this statement is not strictly accurate). Processor architectures like x86 are also called Strong Memory Models; by contrast, PowerPC and ARM are Weak Memory Models. The <code>StoreLoad</code> barrier is particularly special because it is very costly, likely because the CPU uses a Store Buffer to cache the results of write operations, and <code>StoreLoad</code> requires that operations in the Store Buffer be completed before subsequent loads can proceed, significantly increasing load latency.</p><p>Most modern processors guarantee the ordering of dependent loads, i.e., operations like <code>q = p; x = *p;</code>. Among mainstream CPUs, only DEC Alpha does not guarantee this ordering and therefore requires a Dependent Load Barrier between those two instructions (note that another CPU is simultaneously modifying the value of <code>p</code>; see the <a href=https://www.kernel.org/doc/Documentation/memory-barriers.txt>Linux Kernel documentation</a> for details). Processors like Alpha are also called most relaxed memory models.</p><h2 id=memory-model>Memory model</h2><p>As for the definition of a memory model, Wikipedia says: a memory model describes how threads should interact through shared memory (this translation is taken from <a href=http://www.cnblogs.com/catch/p/3803130.html>this article</a>). My own understanding is that a programming language’s memory model provides programmers with a unified view of memory, and when mapping to specific hardware platforms, it must then be translated into the memory models of different CPUs (using the barrier instructions each architecture provides). To maintain portability, a language’s memory model design must necessarily be more general, more likely being something like the greatest lower bound of various hardware models. Therefore, on x86, using <code>std::memory_order_relaxed</code> effectively has no impact, but in order to make programs portable and maximize performance on different hardware platforms, programmers must write code against the memory model provided by C++.</p><h4 id=acquire-and-release-semantics>Acquire and Release semantics</h4><p>There are many different explanations of Acquire and Release semantics online. Some define them separately; others define them together. I prefer the latter approach, which is also the one Herb Sutter uses in his memory model talks (<a href=https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2>part1</a> <a href=https://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2>part2</a>), defined as follows:</p><blockquote><p>If thread A modifies some memory <code>m</code> with a release operation, then in thread A, all memory operations that occur before that release operation become visible to thread B only after B performs an acquire read of <code>m</code>.</p></blockquote><p>Another definition I like uses combinations of the four memory barriers introduced in the previous section (see <a href=http://blog.forecode.com/2010/01/29/barriers-to-understanding-memory-barriers/>this article</a> and <a href=http://preshing.com/20120913/acquire-and-release-semantics/>this article</a>), essentially a mapping:</p><blockquote><p>Acquire == <code>LoadLoad + LoadStore</code></p><p>Release == <code>LoadStore + StoreStore</code></p></blockquote><p>In words:</p><ul><li>Acquire semantics can only be applied to reads of shared memory. Such reads are called <code>read-acquire</code>. Acquire semantics prevent any memory read/write operations after the acquire from being reordered before the acquire.</li><li>Release semantics can only be applied to writes to shared memory. Such writes are called <code>write-release</code>. Release semantics prevent any memory read/write operations before the release from being reordered after the release.</li></ul><p>There are also fence operations with Acquire and Release semantics.</p><p>Acquire and Release must be used in pairs; otherwise they have no effect. This is why it makes sense to discuss them together. In C++11, a <code>write-release</code> operation and a <code>read-acquire</code> operation can form a <code>synchronize-with</code> relationship, which in turn establishes a well-defined <code>happen-before</code> relationship between memory operations before the <code>write-release</code> in one thread and memory operations after the <code>read-acquire</code> in another thread. This prevents the phenomenon described at the beginning of this article, where “B has obviously happened but A has not.”</p><p>Earlier I also mentioned that language-level memory models usually do not have a one-to-one correspondence with hardware-level memory models. In his talk, Herb Sutter mentions that the latest ARMv8 provides load/store instructions <code>ldra</code> and <code>strl</code>, corresponding to <code>read-acquire</code> and <code>write-release</code>, making it the first hardware memory model consistent with a software memory model in this way, theoretically improving performance.</p><h4 id=sequential-consistency-and-sc-drf>Sequential consistency and SC-DRF</h4><p>Sequential Consistency is a stricter semantics than Acquire-Release. It requires that the effects of all memory operations appear in some global order: if one thread thinks operation x happens before operation y, then all threads must agree that x happens before y. Variables marked <code>volatile</code> in Java and C# should have sequentially consistent semantics.</p><p>I don’t really understand how sequential consistency is actually implemented. On almost all architectures, sequential consistency requires using a full barrier. What exactly happens there, how the processor synchronizes caches and memory—one can only know by carefully studying the details of each architecture.</p><p>cppreference gives an extremely mind-bending example of sequential consistency:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;atomic&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> 
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> x <span style=color:#f92672>=</span> {false};
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> y <span style=color:#f92672>=</span> {false};
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> z <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write_x</span>() {
</span></span><span style=display:flex><span>    x.store(true, std<span style=color:#f92672>::</span>memory_order_seq_cst);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write_y</span>() {
</span></span><span style=display:flex><span>    y.store(true, std<span style=color:#f92672>::</span>memory_order_seq_cst);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>read_x_then_y</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>x.load(std<span style=color:#f92672>::</span>memory_order_seq_cst))
</span></span><span style=display:flex><span>        ;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (y.load(std<span style=color:#f92672>::</span>memory_order_seq_cst)) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>z;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>read_y_then_x</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>y.load(std<span style=color:#f92672>::</span>memory_order_seq_cst))
</span></span><span style=display:flex><span>        ;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (x.load(std<span style=color:#f92672>::</span>memory_order_seq_cst)) {
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>z;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> a(write_x);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> b(write_y);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> c(read_x_then_y);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> d(read_y_then_x);
</span></span><span style=display:flex><span>    a.join(); b.join(); c.join(); d.join();
</span></span><span style=display:flex><span>    assert(z.load() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>);  <span style=color:#75715e>// will never happen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This example works correctly only when using sequential consistency; using other models (Acquire-Release semantics) can cause the assert to fire. This example likely requires four CPUs to actually manifest the effect, and my guess is that it’s mostly caused by unsynchronized CPU caches (rather than instruction reordering). Although I can now accept this example, I still feel it’s downright terrifying.</p><p>Herb Sutter also mentioned the term SC-DRF (Sequential Consistent – Data Race Free). The answer on <a href=http://cs.stackexchange.com/questions/29043/why-is-a-program-with-only-atomics-in-sc-drf-but-not-in-hrf-direct>this page</a> explains: “SC-DRF divides memory locations into two kinds: synchronization objects and data objects. Operations on most synchronization objects are guaranteed to be sequentially consistent. If a programmer says that a thread first writes to the atomic object <code>a</code>, and then writes to the data object <code>b</code>, then all threads will observe the same order of writes.”</p><p>I didn’t understand much of the latter half of Herb Sutter’s talk (my listening skills are too poor). I genuinely don’t understand this part yet, so I’m just jotting it down and will revisit it later.</p><h2 id=conclusion>Conclusion</h2><p>I first saw the term Memory Model when reading the book “C++ Concurrency in Action,” whose fifth chapter introduces related content; at the time I didn’t understand any of it. In fact, the earlier book “CLR via C#” that I had read probably also mentioned Memory Order related issues, but I found it equally obscure and difficult. The root cause, I think, is that my learning is largely based on understanding concrete things; I’ve never been keen on abstractions. Memory Order problems aren’t actually abstract, but generally only appear when writing lock-free code, and on x86 they’re even less common. Maybe I can buy a Raspberry Pi and try it on ARM, but that’s for the future. This time I looked into Memory Model issues only because the code I’m writing now needs <code>std::atomic&lt;></code>, and I feel uneasy using it without understanding the Memory Model. The result is that I spent two days reading with no coding done, and after reading I still feel confused and uneasy. I can only say I’m ashamed—my IQ seems insufficient. This article is a summary of what I’ve read over the past two days; I’ll leave it here for now.</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2016/06/effective-modern-cpp-excerpt/ data-tooltip="Effective Modern C++ Study Notes" aria-label="NEXT: Effective Modern C++ Study Notes"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2016/04/suggest-app/ data-tooltip="Recommending a Few Apps" aria-label="PREVIOUS: Recommending a Few Apps"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=gitalk><noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript></div><script src=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript>(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}new Gitalk({clientID:"2d9c9d837f8496107211",clientSecret:"5a474517d0eb6d5abdb90ab9a31c2ba94f4f43b2",repo:"core2duoe6420.github.io",owner:"core2duoe6420",admin:["core2duoe6420"],id:"cf4113f26bd8cf6ea3583de06db42d3b",...{distractionfreemode:!1,enablehotkey:!0,language:"zh-CN",pagerdirection:"first",perpage:10}}).render("gitalk")})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 Powered by Hugo with tranquilpeak. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2016/06/effective-modern-cpp-excerpt/ data-tooltip="Effective Modern C++ Study Notes" aria-label="NEXT: Effective Modern C++ Study Notes"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2016/04/suggest-app/ data-tooltip="Recommending a Few Apps" aria-label="PREVIOUS: Recommending a Few Apps"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"><h4 id=about-card-name>Alex King</h4><div id=about-card-bio>Observing without evaluating is the highest form of human intelligence</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Human</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Shanghai</div></div></div><div id=cover style=background-image:url(https://res.cloudinary.com/core2duoe6420/image/upload/v1643905455/20220204002352_yqvhwd.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://blog.hljin.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script async crossorigin=anonymous defer src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>