<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Effective Modern C++ Study Notes","datePublished":"2016-06-14T00:00:00Z","dateModified":"2016-06-14T00:00:00Z","author":{"@type":"Person","name":"Alex King","image":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.hljin.net\/en-us\/2016\/06\/effective-modern-cpp-excerpt\/"},"publisher":{"@type":"Organization","name":"Alex King's blog","logo":{"@type":"ImageObject","url":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"}},"description":" This article is translated from Chinese to English by ChatGPT. There might be errors.\nThis article contains some study notes from Effective Modern C++.\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Alex King"><meta name=keywords content><meta name=description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This article contains some study notes from Effective Modern C++."><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This article contains some study notes from Effective Modern C++."><meta property="og:type" content="article"><meta property="og:title" content="Effective Modern C++ Study Notes"><meta name=twitter:title content="Effective Modern C++ Study Notes"><meta property="og:url" content="https://blog.hljin.net/en-us/2016/06/effective-modern-cpp-excerpt/"><meta property="twitter:url" content="https://blog.hljin.net/en-us/2016/06/effective-modern-cpp-excerpt/"><meta property="og:site_name" content="Alex King's blog"><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This article contains some study notes from Effective Modern C++."><meta name=twitter:description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

This article contains some study notes from Effective Modern C++."><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2016-06-14T00:00:00"><meta property="article:modified_time" content="2016-06-14T00:00:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta property="og:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><meta property="twitter:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><title>Effective Modern C++ Study Notes</title><link rel=icon href=https://blog.hljin.net/favicon.png><link rel=canonical href=https://blog.hljin.net/en-us/2016/06/effective-modern-cpp-excerpt/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://blog.hljin.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css><link rel=stylesheet href=https://blog.hljin.net/css/override.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://blog.hljin.net/en-us/ aria-label="Go to homepage">Alex King's blog</a></div><a class=header-right-picture href=https://blog.hljin.net/#about aria-label="Open the link: /#about"><img class=header-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://blog.hljin.net/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a><h4 class=sidebar-profile-name>Alex King</h4><h5 class=sidebar-profile-bio>Observing without evaluating is the highest form of human intelligence</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/archives title=Archives><i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden=true></i>
<span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/#about title=About><i class="sidebar-button-icon fas fa-lg fa-user" aria-hidden=true></i>
<span class=sidebar-button-desc>About</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/core2duoe6420 target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>Effective Modern C++ Study Notes</h1><div class="postShorten-meta post-meta"><time datetime=2016-06-14T00:00:00Z>June 14, 2016</time></div></div><div class="post-content markdown"><div class=main-content-wrap><div class="alert warning"><p>This article is translated from Chinese to English by ChatGPT. There might be errors.</p></div><p>This article contains some study notes from Effective Modern C++.</p><h2 id=type-deduction-rules-1-2>Type Deduction Rules #1 #2</h2><p>For code of the form</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> f(ParamType param);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f(expr);
</span></span></code></pre></div><p><code>T</code> and <code>ParamType</code> are deduced from <code>expr</code>. There are three cases:</p><ul><li><code>ParamType</code> is a pointer or reference type, but not a universal reference (of the form <code>T&&</code>);</li><li><code>ParamType</code> is a universal reference;</li><li><code>ParamType</code> is neither a pointer nor a reference.</li></ul><p>Basic rules:</p><ul><li>When <code>ParamType</code> is a reference, the reference is ignored when deducing <code>T</code>, while <code>const</code> and <code>volatile</code> are preserved;</li><li>When <code>ParamType</code> is a universal reference, if <code>expr</code> is an lvalue, <code>T</code> and <code>param</code> will be deduced as lvalue reference types; if <code>expr</code> is an rvalue, the reference is ignored when deducing <code>T</code>, and <code>param</code> is deduced as an rvalue reference;</li><li>When <code>ParamType</code> is neither a reference nor a pointer, references are ignored during deduction, and <code>const</code> and <code>volatile</code> are also ignored;</li><li>When <code>expr</code> is an array or a function pointer, if <code>ParamType</code> is not a reference, the deduced <code>T</code> is a pointer type; if <code>ParamType</code> is a reference, the deduced <code>T</code> is an array type (for example <code>char[5]</code>) or a function reference (for example <code>void (&)(int)</code>).</li></ul><p>In short, <code>T</code> is deduced as an lvalue reference type (such as <code>int&</code>) only in one situation: when <code>ParamType</code> is a universal reference and <code>expr</code> is an lvalue.</p><h2 id=decltype-3><code>decltype</code> #3</h2><p>In most cases, <code>decltype</code> returns the exact type of an expression, including reference types and <code>const volatile</code>.</p><p>In C++14, <code>decltype(auto)</code> can be used to deduce a function’s return type automatically.</p><p>Note that for a variable name whose type is <code>T</code>, <code>decltype</code> yields <code>T</code>; but for an expression of type <code>T</code> that is an <em>lvalue</em>, <code>decltype</code> yields the reference type <code>T&</code>. For example, with <code>int x = 0;</code>, <code>decltype((x))</code> yields <code>int&</code>.</p><h2 id=auto-5-6><code>auto</code> #5 #6</h2><p>Using <code>auto</code> for type deduction reduces typing, avoids some subtle type issues, and lowers refactoring costs. In C++14, <code>auto</code> can be used in lambda parameter lists.</p><p>When declaring variables with <code>auto</code>, be careful about interfaces that use the Proxy design pattern, which may not return the actual object you want. In these cases you can use <code>static_cast</code> to convert the type, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> x <span style=color:#f92672>=</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>type_you_want<span style=color:#f92672>&gt;</span>(proxy_expr);
</span></span></code></pre></div><h2 id=uniform-initialization-brace-initialization-7>Uniform Initialization (Brace Initialization) #7</h2><p>Initialization forms include:</p><ul><li>Copy (=) initialization: <code>int y = 0;</code>. Non-copyable objects cannot use copy initialization; for example <code>std::atomic&lt;int> x = 0;</code> is <strong>ill-formed</strong>;</li><li>Direct (parentheses) initialization: <code>int y(0);</code>. Cannot be used to specify default values for data members;</li><li>Uniform (brace) initialization (with or without <code>=</code>): <code>int y{ 0 };</code>. Can be used in all situations.</li></ul><p>When a class has a constructor overload taking <code>initializer_list&lt;T></code>, the compiler will <strong>strongly</strong> prefer this overload, even if other constructors would match the arguments better. Note the difference between the following two statements:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> x1(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>);
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> x2{<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>};
</span></span></code></pre></div><p>When writing templates, you must choose between these two construction forms.</p><p>Using an empty initializer list calls the default constructor, for example <code>Widget w{};</code>. Parentheses initialization (<code>Widget w();</code>) cannot be used here, because the compiler tends to interpret the statement as a function declaration, which is the C++ “most vexing parse” problem. To select the <code>initializer_list</code> constructor, you can use <code>Widget w{{}};</code>.</p><p>In addition, <code>auto</code> can do two-step deduction with <code>initializer_list&lt;T></code>, i.e. <code>auto x = { 1, 2 };</code> is directly deduced as <code>initializer_list&lt;int></code>. But for template argument deduction, the C++ standard forbids deducing <code>initializer_list&lt;T></code> directly from an initializer list. When you need this, the template function should be declared as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> func(<span style=color:#66d9ef>const</span> initializer_list<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> il);
</span></span></code></pre></div><p>When initializing an object with <code>=</code> and with parentheses, there is a difference (#42):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>regex r1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;       <span style=color:#75715e>// copy initialization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>regex r2(<span style=color:#66d9ef>nullptr</span>);        <span style=color:#75715e>// direct initialization
</span></span></span></code></pre></div><p>The C++ standard forbids calling <code>explicit</code> constructors for copy initialization, but allows them for direct initialization.</p><h2 id=nullptr-8><code>nullptr</code> #8</h2><p><code>nullptr</code> is better than <code>NULL</code> in avoiding overload ambiguities, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>f</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f(NULL);    <span style=color:#75715e>// may fail to compile, or choose f(int)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>f(<span style=color:#66d9ef>nullptr</span>); <span style=color:#75715e>// ok, chooses f(void *)
</span></span></span></code></pre></div><h2 id=using-using-for-type-aliases-9>Using <code>using</code> for Type Aliases #9</h2><p>Use <code>using</code> instead of <code>typedef</code> to define aliases; advantages:</p><ul><li><code>using</code> supports templates, for example:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> MyAllocList <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>list<span style=color:#f92672>&lt;</span>T, MyAlloc<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>;
</span></span></code></pre></div><ul><li>When using a type defined with <code>using</code> inside templates, you usually don’t need the <code>typename</code> keyword, because the compiler knows that a <code>using</code> declaration always introduces a type.</li></ul><p>Some type utilities in <code>&lt;type_traits></code> still use <code>typedef</code> in C++11; C++14 adds <code>using</code>-based versions, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>remove_const<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;::</span>type <span style=color:#75715e>// C++11
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>remove_const_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>     <span style=color:#75715e>// C++14
</span></span></span></code></pre></div><h2 id=scoped-enums-10>Scoped Enums #10</h2><p>For enums declared with <code>enum class</code>, enumerators must be qualified with the enum’s scope, for example <code>enum class Color { black, red }; auto c = Color::red;</code>.</p><p>Enumerators declared with <code>enum class</code> are not implicitly convertible to fundamental types (<code>int</code>, <code>double</code>, etc.); explicit casts are required when needed.</p><p>Both old-style <code>enum</code> and <code>enum class</code> have an underlying type. The default underlying type for <code>enum class</code> is <code>int</code>, and both forms can specify an underlying type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Status</span> <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>uint32_t</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Color</span> <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>uint8_t</span>;
</span></span></code></pre></div><p>After specifying an underlying type, both support forward declarations. You can use <code>std::underlying_type&lt;E>::type</code> in <code>&lt;type_traits></code> to obtain an enum’s underlying type.</p><h2 id=delete-11><code>delete</code> #11</h2><p><code>delete</code> can be used not only on member functions, but on any function, including specialized template functions, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> func(T t);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> func<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>int</span> t) <span style=color:#f92672>=</span> <span style=color:#66d9ef>delete</span>;
</span></span></code></pre></div><h2 id=new-function-specifiers-12-14>New Function Specifiers #12 #14</h2><p>C++11 adds the following function specifiers:</p><ul><li><code>&</code> and <code>&&</code> for member functions, enabling overloads that are selected depending on whether <code>*this</code> is an lvalue or rvalue;</li><li><code>override</code> explicitly informs the compiler that a function overrides a base-class method. Because overriding requires many conditions to hold, it’s easy to write code that appears to override but actually doesn’t; <code>override</code> lets the compiler catch such errors;</li><li><code>final</code> applied to a class or function, indicating that the class cannot be derived from, or the function cannot be overridden;</li><li><code>noexcept</code> declares that a function does not throw exceptions. In C++11, the only really useful information about exceptions is “whether a function may throw.” Many functions are designed with the requirement that callees must not throw, such as <code>std::vector::push_back</code>; it will use the move constructor only when the element type’s move constructor is declared <code>noexcept</code>, otherwise for exception safety it will use the copy constructor. Many STL functions depend on this property. Destructors are <code>noexcept</code> by default. If a function marked <code>noexcept</code> throws, the program is terminated.</li></ul><h2 id=rules-for-generating-special-member-functions-17>Rules for Generating Special Member Functions #17</h2><p>The Big Five principle: if any of the copy operations, move operations, or destructor has user-defined behavior, the compiler should not assume its auto-generated bitwise operations are correct. C++11 designs move operations according to this principle, but in C++98, the principle was not yet clear when specifying copy operations, so their behavior differs somewhat.</p><ul><li>Default constructor: generated automatically if the user does not define one;</li><li>Destructor: generated automatically if the user does not define one; implicitly <code>noexcept</code>, and by default <strong>not</strong> <code>virtual</code>;</li><li>Copy constructor: generated automatically if the user does not define a copy constructor or any move operations; the presence of a user-defined destructor does not prevent generation of the copy constructor, but this behavior is deprecated;</li><li>Copy assignment operator: generated automatically if the user does not define a copy assignment operator or any move operations; the presence of a user-defined destructor does not prevent generation of the copy assignment operator, but this behavior is deprecated;</li><li>Move constructor and move assignment operator: generated automatically only if the user does not define any copy operations, move operations, or a destructor;</li><li>Member function templates have no effect on the generation of these special member functions.</li></ul><h2 id=smart-pointers-1822>Smart Pointers #18–#22</h2><ol><li><code>std::unique_ptr</code> has performance comparable to raw pointers. When using the default deleter (<code>delete</code>) or a lambda expression as the deleter, the size of <code>std::unique_ptr</code> does not change, because the deleter is part of the <code>std::unique_ptr</code>’s type information. Using a function pointer or function object increases its size;</li><li><code>std::unique_ptr</code> has a partial specialization for arrays: <code>std::unique_ptr&lt;T[]></code>. The array version does not support <code>operator*</code> and <code>operator-></code>, but does support <code>operator[]</code> (the non-array version does not support indexing);</li><li><code>std::shared_ptr</code> and <code>std::weak_ptr</code> typically occupy the size of two pointers, one pointing to the object and one to the control block. The control block contains the strong reference count and weak reference count. When the strong count reaches 0, the object is destroyed and its memory is reclaimed (unless it was not allocated via <code>std::make_shared</code>); when both strong and weak counts are 0, the control block itself is deallocated. All reference count operations are atomic, which affects performance. The control block also stores custom allocators (via <code>std::allocate_shared</code>) and deleters. A <code>std::shared_ptr</code>’s deleter is specified via its constructor and is not part of the template type;</li><li>If a member function needs to obtain a <code>std::shared_ptr</code> to <code>this</code>, the class must inherit from <code>std::enable_shared_from_this&lt;T></code> and then call <code>shared_from_this()</code>. Before calling this function, the instance must already have an associated control block, i.e. at least one <code>std::shared_ptr</code> has been created for it; otherwise an exception is thrown;</li><li>When using the pImpl idiom, if you manage resources with <code>std::unique_ptr</code>, the deleter is part of the <code>std::unique_ptr</code>’s type, and thus the implementation type must be complete, so you must declare the Big Five in the header and define them in the implementation file; if you use <code>std::shared_ptr</code>, this is not required;</li><li>Use the <code>make_xxx</code> family with care or not at all in the following situations:<ul><li>When a custom deleter is required;</li><li>When the object must be constructed with <code>std::initializer_list</code>;</li><li>When the class defines custom <code>operator new</code> and <code>operator delete</code>;</li><li>When the object itself is large and weak references will live for a long time (because the control block and object are allocated together, the object’s memory lifetime matches that of the control block).</li></ul></li></ol><h2 id=move-semantics-and-perfect-forwarding-2330>Move Semantics and Perfect Forwarding #23–#30</h2><p>A simple C++14 implementation of <code>std::move</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>decltype</span>(<span style=color:#66d9ef>auto</span>) move(T<span style=color:#f92672>&amp;&amp;</span> param) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> ReturnType <span style=color:#f92672>=</span> remove_reference_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;&amp;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>ReturnType<span style=color:#f92672>&gt;</span>(param);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>A simple C++14 implementation of <code>std::forward</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T<span style=color:#f92672>&amp;&amp;</span> forward(remove_reference_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> param) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&amp;&amp;&gt;</span>(param);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>std::move</code> always returns an rvalue reference to <code>param</code>; <code>std::forward</code> preserves the value category of <code>param</code>: if <code>param</code> is an lvalue, it returns an lvalue reference; if <code>param</code> is an rvalue, it returns an rvalue reference.</p><p>Guidelines:</p><ul><li>Call <code>std::move</code> on variables that are rvalue references;</li><li>Call <code>std::forward</code> on variables that are universal references (in templates);</li><li>Apply the above only when you are sure the variable will not be used afterward, to avoid accidentally moving from an object that is still needed.</li></ul><p>Situations where perfect forwarding via <code>std::forward</code> may fail:</p><ul><li>Brace initialization;</li><li>Using <code>NULL</code> or <code>0</code> for null pointers, which can conflict with overloads for integer types; use <code>nullptr</code> instead;</li><li>Forwarding <code>static const</code> variables that are declared but not defined. Perfect forwarding forwards references and may require taking the variable’s address. Undeclared definitions have no address, leading to link errors. The variable must be defined;</li><li>Forwarding overloaded functions, because it is unclear which overload is intended, leading to ambiguity. Specify the function signature explicitly;</li><li>Using bitfields. C++ explicitly forbids binding non-<code>const</code> references to bitfields. Even if the parameter is a <code>const</code> reference, the bitfield is first copied into an integer, and the reference binds to that. The workaround is to copy into a variable first and then call the function.</li></ul><h4 id=reference-collapsing>Reference Collapsing</h4><p>Reference collapsing rules: if any of the references being collapsed is an lvalue reference, the result is an lvalue reference; only if all references are rvalue references is the result an rvalue reference.</p><p>Reference collapsing can occur:</p><ul><li>During template argument instantiation;</li><li>When deducing variable types with <code>auto</code>;</li><li>When using <code>typedef</code> for types in templates;</li><li>When using <code>decltype</code>.</li></ul><p><strong>New definition of universal references:</strong> a universal reference is, effectively, an rvalue reference in a context where both of the following hold:</p><ul><li>Type deduction distinguishes between lvalues and rvalues: an lvalue of type <code>T</code> is deduced as <code>T&</code>, an rvalue of type <code>T</code> as <code>T</code>;</li><li>Reference collapsing occurs.</li></ul><h4 id=universal-references-and-overloading>Universal References and Overloading</h4><p>When universal references are combined with overloading, things can get tricky, because the compiler tends to instantiate a template to create a perfect match instead of choosing another overload that requires a conversion. Possible issues:</p><ul><li>Numeric types are not converted (e.g., <code>short</code> promoted to <code>int</code>); instead, a template is instantiated to create a perfect match;</li><li>When calling a copy constructor with a non-<code>const</code> object, the copy constructor may not be chosen, because a <strong>non-<code>const</code></strong> constructor generated from a template is a better match;</li><li>When a derived class calls a base-class constructor, the constructor generated from a template may be chosen because its type match is better.</li></ul><p>Possible solutions:</p><ul><li>Avoid overloading; use different function names instead. This does not apply to constructors;</li><li>Pass variables by <code>const T&</code>. This forfeits the performance benefits of universal references (moves, constructing from string literals without creating temporary <code>std::string</code>s, etc.);</li><li>Use tag dispatch. Overload resolution is based on matching all function parameters and arguments, so you can use an extra parameter to influence overload selection, such as <code>std::true_type</code> and <code>std::false_type</code>. These parameters are used only for overload resolution, need no variable name, and are not part of the runtime code, hence “tags”;</li><li>Constrain templates with <code>std::enable_if</code>. Using SFINAE (Substitution Failure Is Not An Error), substitution failures do not cause errors. For example, code to address the three issues above:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typename</span> T,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>typename</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>enable_if_t<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>std<span style=color:#f92672>::</span>is_base_of<span style=color:#f92672>&lt;</span>Person, std<span style=color:#f92672>::</span>decay_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;::</span>value
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>!</span>std<span style=color:#f92672>::</span>is_integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_reference_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;::</span>value
</span></span><span style=display:flex><span>        <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> Person(T<span style=color:#f92672>&amp;&amp;</span> n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>Person</span>(<span style=color:#66d9ef>int</span> idx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>If this kind of code fails, compilers can emit a huge amount of diagnostics. You can use <code>static_assert</code> to localize the error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    <span style=color:#66d9ef>static_assert</span>(
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>is_constructible<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string, T<span style=color:#f92672>&gt;::</span>value,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Parameter n can&#39;t be used to construct a std::string&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span></code></pre></div><h2 id=lambda-expressions-3134>Lambda Expressions #31–#34</h2><p>Each lambda expression generates a unique lambda class; a closure is an instance of that class.</p><p>Notes on lambda captures:</p><ul><li>Default capture captures the <code>this</code> pointer, which may cause dangling pointer issues;</li><li>Static-storage-duration variables, such as those declared with <code>static</code>, cannot be captured.</li></ul><p>Since C++14, init-capture is supported, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>[pw <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>move(pw)]() {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Init-capture allows moving objects into the closure. C++11 does not support init-capture; to move parameters into a closure, you must simulate it with <code>std::bind()</code>.</p><p>Since C++14, generic lambdas are supported; you can use <code>auto</code> in parameter types, implemented internally with templates. When you need perfect forwarding, use <code>decltype</code> on the parameter name to deduce its type, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> f <span style=color:#f92672>=</span> [] (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;&amp;</span> param) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>func</span>(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span>(param)<span style=color:#f92672>&gt;</span>(param));
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=concurrency-programming-3540>Concurrency Programming #35–#40</h2><h4 id=stdasync><code>std::async()</code></h4><p><code>std::async()</code> provides a task-based concurrency model. Its built-in scheduler avoids problems caused by manually using <code>std::thread</code>, such as too many threads, frequent context switching, and portability issues (when writing your own scheduler). It also lets you retrieve return values or exceptions from the associated <code>std::future</code>. When you need low-level APIs (CPU affinity, thread priority, etc.), you must use <code>std::thread</code>.</p><p><code>std::async()</code> supports two launch policies: concurrent execution (<code>std::launch::async</code>) and deferred execution (<code>std::launch::deferred</code>). With deferred execution, the task body runs in the caller’s thread when <code>std::future::get()</code> is called. The default policy is both (<code>std::launch::async | std::launch::deferred</code>), leaving the scheduler to choose at runtime based on system load. Because of this nondeterminism, you should use the default only when all of the following hold; otherwise specify the launch policy explicitly:</p><ul><li>The task does not need to run concurrently with the thread calling <code>get</code> or <code>wait</code>;</li><li>You don’t need to read or write <code>thread_local</code> variables of a specific thread;</li><li>Unless you can guarantee that <code>get()</code> or <code>wait()</code> will be called on the <code>std::future</code> returned by <code>std::async()</code>, the task might never run (if the scheduler chooses <code>deferred</code> under heavy load);</li><li>When calling <code>wait_for()</code> or <code>wait_until()</code>, consider the <code>std::future_status::deferred</code> state.</li></ul><h4 id=stdthread><code>std::thread</code></h4><p>When a <code>std::thread</code> is destroyed, it must be in an unjoinable state, i.e., detached from the underlying OS thread. A <code>std::thread</code> is unjoinable in the following situations:</p><ul><li>Default-constructed <code>std::thread</code>;</li><li>A <code>std::thread</code> that has been moved from;</li><li>A <code>std::thread</code> on which <code>join()</code> has already been called;</li><li>A <code>std::thread</code> on which <code>detach()</code> has already been called.</li></ul><h4 id=stdfuture><code>std::future</code></h4><p><code>std::future</code> is movable but not copyable, and <code>get()</code> can be called only once; calling <code>get()</code> again is an error. Calling <code>std::future::share()</code> creates a <code>std::shared_future</code>, which is copyable and allows multiple calls to <code>get()</code>, enabling safe sharing among threads; concurrent access through separate <code>std::shared_future</code> objects is thread-safe.</p><p><code>std::promise</code> can also create a <code>std::future</code>; they communicate via a heap-allocated shared state that also contains a reference count.</p><p>The destructor of <code>std::future</code> usually just destroys its data members, but when the <code>std::future</code> was created by <code>std::async()</code> with the <code>async</code> policy (which creates a new thread) and is the last <code>future</code> pointing to the shared state, its destructor will block until the task is finished (i.e., it effectively calls <code>join()</code> on the thread).</p><p><code>std::future&lt;void></code> can be used for one-time communication between threads.</p><h4 id=volatile><code>volatile</code></h4><p>The <code>volatile</code> keyword prevents the compiler from optimizing away accesses to a specific memory location. For example, code like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> y <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>y <span style=color:#f92672>=</span> x;       <span style=color:#75715e>// redundant loads
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;      <span style=color:#75715e>// dead stores
</span></span></span></code></pre></div><p>is likely to be optimized to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> y <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>;
</span></span></code></pre></div><p>Using <code>volatile</code> disables such optimizations.</p><h2 id=emplace-functions-42><code>emplace</code> Functions #42</h2><p>The <code>emplace</code> family is not always faster than <code>push</code>/<code>insert</code>. Performance is usually better only when all of the following conditions hold:</p><ul><li>The value is constructed directly in the container, not inserted via assignment (<code>operator=</code>) (e.g., inserting at the front of a <code>vector</code>);</li><li>The argument types differ from the container’s element type (so <code>push</code>/<code>insert</code> would need to construct a temporary object first);</li><li>The container is unlikely to reject inserts due to duplicate values.</li></ul><p>When inserting resource-managing objects (e.g. <code>std::shared_ptr</code>) into containers, you must create the resource-managing object first. With <code>emplace</code>, there may be a gap between acquiring a resource and creating its managing object; if an exception occurs in this interval (e.g. <code>vector</code> reallocation fails due to insufficient memory), the resource may leak. The following code has potential leakage risk:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>list<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Widget<span style=color:#f92672>&gt;&gt;</span> ptrs;
</span></span><span style=display:flex><span>ptrs.emplace_back(<span style=color:#66d9ef>new</span> Widget, killWidget);
</span></span></code></pre></div><p>With <code>emplace</code>, arguments are perfectly forwarded to the constructor, which means direct initialization is used and <code>explicit</code> constructors are allowed. This does not happen with <code>push</code>/<code>insert</code>, because the compiler does not allow <code>explicit</code> constructors to be used implicitly when creating temporaries.</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">TAGGED IN</span><br><a class="tag tag--primary tag--small" href=https://blog.hljin.net/en-us/tags/c++/>C++</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2017/09/bash-concept-and-syntax/ data-tooltip="BASH Concepts and Common Syntax" aria-label="NEXT: BASH Concepts and Common Syntax"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2016/05/memory-model/ data-tooltip="What the HELL is MEMORY MODEL" aria-label="PREVIOUS: What the HELL is MEMORY MODEL"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=gitalk><noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript></div><script src=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript>(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}new Gitalk({clientID:"2d9c9d837f8496107211",clientSecret:"5a474517d0eb6d5abdb90ab9a31c2ba94f4f43b2",repo:"core2duoe6420.github.io",owner:"core2duoe6420",admin:["core2duoe6420"],id:"42346ae7c96ae363b2f41dc1b8aaabc1",...{distractionfreemode:!1,enablehotkey:!0,language:"zh-CN",pagerdirection:"first",perpage:10}}).render("gitalk")})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 Powered by Hugo with tranquilpeak. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2017/09/bash-concept-and-syntax/ data-tooltip="BASH Concepts and Common Syntax" aria-label="NEXT: BASH Concepts and Common Syntax"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2016/05/memory-model/ data-tooltip="What the HELL is MEMORY MODEL" aria-label="PREVIOUS: What the HELL is MEMORY MODEL"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"><h4 id=about-card-name>Alex King</h4><div id=about-card-bio>Observing without evaluating is the highest form of human intelligence</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Human</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Shanghai</div></div></div><div id=cover style=background-image:url(https://res.cloudinary.com/core2duoe6420/image/upload/v1643905455/20220204002352_yqvhwd.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://blog.hljin.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script async crossorigin=anonymous defer src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>