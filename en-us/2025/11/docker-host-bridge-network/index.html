<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Bridging to Host Network","datePublished":"2025-11-11T00:00:00Z","dateModified":"2025-11-11T00:00:00Z","author":{"@type":"Person","name":"Alex King","image":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.hljin.net\/en-us\/2025\/11\/docker-host-bridge-network\/"},"publisher":{"@type":"Organization","name":"Alex King's blog","logo":{"@type":"ImageObject","url":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"}},"description":" This article is translated from Chinese to English by ChatGPT. There might be errors.\nThe subtitle of this post could be “My Hacky Docker Networking Setup”. It mainly describes the pitfalls I ran into when configuring Docker to bridge to the host network.\nDocker’s bridge network is an internal network; all communication with the outside world has to go through L3 routing and NAT, which is inconvenient for some applications. If you want to bridge to the host network, the simplest approach is to use macvlan. However, macvlan has the drawback that it cannot communicate with the host, so it’s not a perfect solution.\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Alex King"><meta name=keywords content><meta name=description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

The subtitle of this post could be “My Hacky Docker Networking Setup”. It mainly describes the pitfalls I ran into when configuring Docker to bridge to the host network.
Docker’s bridge network is an internal network; all communication with the outside world has to go through L3 routing and NAT, which is inconvenient for some applications. If you want to bridge to the host network, the simplest approach is to use macvlan. However, macvlan has the drawback that it cannot communicate with the host, so it’s not a perfect solution."><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

The subtitle of this post could be “My Hacky Docker Networking Setup”. It mainly describes the pitfalls I ran into when configuring Docker to bridge to the host network.
Docker’s bridge network is an internal network; all communication with the outside world has to go through L3 routing and NAT, which is inconvenient for some applications. If you want to bridge to the host network, the simplest approach is to use macvlan. However, macvlan has the drawback that it cannot communicate with the host, so it’s not a perfect solution."><meta property="og:type" content="article"><meta property="og:title" content="Docker Bridging to Host Network"><meta name=twitter:title content="Docker Bridging to Host Network"><meta property="og:url" content="https://blog.hljin.net/en-us/2025/11/docker-host-bridge-network/"><meta property="twitter:url" content="https://blog.hljin.net/en-us/2025/11/docker-host-bridge-network/"><meta property="og:site_name" content="Alex King's blog"><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

The subtitle of this post could be “My Hacky Docker Networking Setup”. It mainly describes the pitfalls I ran into when configuring Docker to bridge to the host network.
Docker’s bridge network is an internal network; all communication with the outside world has to go through L3 routing and NAT, which is inconvenient for some applications. If you want to bridge to the host network, the simplest approach is to use macvlan. However, macvlan has the drawback that it cannot communicate with the host, so it’s not a perfect solution."><meta name=twitter:description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

The subtitle of this post could be “My Hacky Docker Networking Setup”. It mainly describes the pitfalls I ran into when configuring Docker to bridge to the host network.
Docker’s bridge network is an internal network; all communication with the outside world has to go through L3 routing and NAT, which is inconvenient for some applications. If you want to bridge to the host network, the simplest approach is to use macvlan. However, macvlan has the drawback that it cannot communicate with the host, so it’s not a perfect solution."><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2025-11-11T00:00:00"><meta property="article:modified_time" content="2025-11-11T00:00:00"><meta property="article:tag" content="docker"><meta name=twitter:card content="summary"><meta property="og:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><meta property="twitter:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><title>Docker Bridging to Host Network</title><link rel=icon href=https://blog.hljin.net/favicon.png><link rel=canonical href=https://blog.hljin.net/en-us/2025/11/docker-host-bridge-network/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://blog.hljin.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css><link rel=stylesheet href=https://blog.hljin.net/css/override.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://blog.hljin.net/en-us/ aria-label="Go to homepage">Alex King's blog</a></div><a class=header-right-picture href=https://blog.hljin.net/#about aria-label="Open the link: /#about"><img class=header-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://blog.hljin.net/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a><h4 class=sidebar-profile-name>Alex King</h4><h5 class=sidebar-profile-bio>Observing without evaluating is the highest form of human intelligence</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/archives title=Archives><i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden=true></i>
<span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/#about title=About><i class="sidebar-button-icon fas fa-lg fa-user" aria-hidden=true></i>
<span class=sidebar-button-desc>About</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/core2duoe6420 target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>Docker Bridging to Host Network</h1><div class="postShorten-meta post-meta"><time datetime=2025-11-11T00:00:00Z>November 11, 2025</time></div></div><div class="post-content markdown"><div class=main-content-wrap><div class="alert warning"><p>This article is translated from Chinese to English by ChatGPT. There might be errors.</p></div><p>The subtitle of this post could be “My Hacky Docker Networking Setup”. It mainly describes the pitfalls I ran into when configuring Docker to bridge to the host network.</p><p>Docker’s bridge network is an internal network; all communication with the outside world has to go through L3 routing and NAT, which is inconvenient for some applications. If you want to bridge to the host network, the simplest approach is to use macvlan. However, macvlan has the drawback that it cannot communicate with the host, so it’s not a perfect solution.</p><p>My host has multiple NICs, so a long time ago I put them all into a single bridge, similar to <code>br-lan</code> in OpenWRT. This setup gave me a way to work around macvlan’s limitation. The idea is simple: macvlan can’t talk directly to the host, so I create a veth pair, put one end into the host bridge, and use the other end as the parent for the macvlan. In that case, it doesn’t matter that the macvlan can’t talk to the veth. This setup works very well in most cases; both my HomeAssistant and UniFi-Controller use this scheme.</p><p>Readers of my previous DSM post will know that I also have a WebVirtCloud. I wanted the VMs inside that container to also be bridged directly onto the host network. That’s where macvlan fails, because interfaces created by macvlan cannot be added into a bridge, i.e., they cannot be bridged again. To solve this, my approach was to create another Docker network, then create a veth pair, adding one end to the main bridge and the other end to the new Docker bridge. After the container starts, I manually modify the IP address and default route. This solution is quite hacky: it requires the container to have the NET_ADMIN capability and a script to configure IP addresses, but it works.</p><p>In retrospect, when I first implemented this hacky solution, I already ran into the very issues described in this post. Somehow I came up with a workaround at the time; the problem was solved, but I never fully understood it, nor did I document it. As a result, today I stepped into the same trap again.</p><p>Here’s what happened. My previous hack existed because I hadn’t found a way to let Docker directly use an already-created bridge. Recently I decided to search again and found <a href=https://github.com/moby/libnetwork/issues/2310>this issue</a>. Docker has improved in the past couple of years and now seems to support using an existing bridge, so I tried it—and immediately hit some weird network problems again.</p><p>First, I defined the bridge and veth with netplan (my host is Ubuntu 24.04), roughly as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>network</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>version</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>bridges</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># This is my host bridge; unrelated content omitted</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>br-mellanox</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>addresses</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.137.250</span><span style=color:#ae81ff>/24</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>interfaces</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>eno1</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>veth-lan137-2</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>nameservers</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>addresses</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ae81ff>192.168.137.245</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>search</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ae81ff>hljin.net</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>routes</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>to</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>via</span>: <span style=color:#ae81ff>192.168.137.245</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># This is for container bridging</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>br-lan137</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>interfaces</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>veth-lan137-1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>virtual-ethernets</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>veth-lan137-1</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>peer</span>: <span style=color:#ae81ff>veth-lan137-2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>veth-lan137-2</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>peer</span>: <span style=color:#ae81ff>veth-lan137-1</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>ethernets</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>eno1</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>optional</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>dhcp4</span>: <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><p>Then I created the Docker network with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --driver bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --subnet 192.168.137.0/24 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --gateway 192.168.137.245 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.enable_icc<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.enable_ip_masquerade<span style=color:#f92672>=</span>false <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.gateway_mode_ipv4<span style=color:#f92672>=</span>routed  <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.driver.mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.name<span style=color:#f92672>=</span>br-lan137 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.inhibit_ipv4<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    lan137
</span></span></code></pre></div><p>Next, when creating containers, I just specify the <code>lan137</code> network and assign a fixed IP. With docker-compose it looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>homeassistant</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># other config</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>lan137</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>ipv4_address</span>: <span style=color:#ae81ff>192.168.137.248</span>
</span></span><span style=display:flex><span><span style=color:#f92672>networks</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>lan137</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>external</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>lan137</span>
</span></span></code></pre></div><p>After starting, a problem surfaced: from the container, networking was mostly fine; it could talk to all devices on the LAN, except it couldn’t connect to services exposed on the host via Docker (i.e., containers on the default Docker bridge, with ports published using <code>--publish</code>, which is how most of my containers are set up). For example, <code>192.168.137.250:5000</code> was unreachable from the container, although ping worked.</p><p>With extensive help from ChatGPT, I spent an entire day investigating. That took so long because this failure was actually composed of four smaller issues, and I still don’t fully understand the last one.</p><h2 id=issue-1-bridge-nf-call-iptables>Issue 1: <code>bridge-nf-call-iptables</code></h2><p>In my mental model, the packet should go through <code>br-lan137</code>, then be forwarded via the veth to <code>br-mellanox</code>, then enter the host network stack and be DNATed by iptables to the container IP (in <code>172.18.0.0/16</code>). However, because <code>net.bridge.bridge-nf-call-iptables = 1</code>, the packet already enters the iptables pipeline when it hits <code>br-lan137</code>. This part is not hard to reason about, but I initially suspected that the connectivity issue was caused by firewall rules, so I kept searching for rules related to <code>br-lan137</code> and found nothing. Only later did I realize the key wasn’t filtering, but that the packet had already hit the <code>PREROUTING</code> <code>DNAT</code> on <code>br-lan137</code>, because that rule does not distinguish by input device:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo iptables -t nat -L -n -v
</span></span><span style=display:flex><span>Chain PREROUTING (policy ACCEPT 928K packets, 63M bytes)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span> 5376  320K DOCKER     0    --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER (2 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>    0     0 RETURN     0    --  docker0 *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span> 1738  104K RETURN     0    --  br-da66fb6805df *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span> 1780  107K DNAT       6    --  !br-da66fb6805df *       0.0.0.0/0            0.0.0.0/0            tcp dpt:5000 to:172.18.0.4:5000
</span></span></code></pre></div><p>So the packet is already DNATed to <code>172.18.0.4</code> at <code>br-lan137</code>, and its outgoing device should be <code>br-da66fb6805df</code>. That’s why I couldn’t find any relevant firewall rule for <code>br-lan137</code>.</p><h2 id=issue-2-forward-rules>Issue 2: <code>FORWARD</code> rules</h2><p>Once Issue 1 was clear, locating the relevant firewall rules wasn’t hard. For clarity, here’s a condensed version showing only the important parts:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo iptables -L -n -v
</span></span><span style=display:flex><span>Chain FORWARD (policy DROP 0 packets, 0 bytes)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>7238K 3417M DOCKER-FORWARD  0    --  *      *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER-FORWARD (1 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>6716K 3069M DOCKER-ISOLATION-STAGE-1  0    --  *      *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER-ISOLATION-STAGE-1 (1 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>  227 13620 DOCKER-ISOLATION-STAGE-2  0    --  br-lan137 !br-lan137  0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span> 631K   64M DOCKER-ISOLATION-STAGE-2  0    --  br-da66fb6805df !br-da66fb6805df  0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER-ISOLATION-STAGE-2 (3 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>  218 13080 DROP       0    --  *      br-da66fb6805df  0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>    0     0 DROP       0    --  *      br-lan137  0.0.0.0/0            0.0.0.0/0
</span></span></code></pre></div><p>The main purpose of these rules is to isolate different Docker networks (bridges) from one another. However, even after adding rules to bypass iptables, the network was still not working, which leads to the third issue.</p><h2 id=issue-3-rp_filter>Issue 3: <code>rp_filter</code></h2><p><code>rp_filter</code> ensures that the source IP of a packet is routable from this host, mainly to mitigate DDoS attacks. The default <code>rp_filter=2</code> is a relatively loose policy: the SRC IP only needs to be routable via any interface on the host. In my case, <code>192.168.137.0/24</code> is the host’s own network, so it is definitely routable. I therefore couldn’t see how <code>rp_filter</code> could be related to this problem. But after disabling <code>rp_filter</code>, TCP handshakes started to succeed, so I had to accept it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -w net.ipv4.conf.all.rp_filter<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>sysctl -w net.ipv4.conf.br-lan137.rp_filter<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Later, ChatGPT mentioned the <code>fib_validate_source()</code> function, which led me to <a href=https://github.com/centurycoder/martian_source>this article</a>. That’s where I learned that an interface without an IP can also trigger <code>rp_filter</code>, whereas in my mental model <code>br-lan137</code> was purely a L2 device and didn’t need an IP.</p><p>The verification method is simple: assign any random IP to <code>br-lan137</code>; the specific IP doesn’t matter.</p><p>After fixing the firewall and <code>rp_filter</code>, I ran into the most confusing part of this entire troubleshooting session. The network still didn’t work, but the symptoms changed: TCP could handshake successfully, but the connection was immediately reset:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># telnet 192.168.137.250 5000
</span></span><span style=display:flex><span>Connected to 192.168.137.250
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># curl http://192.168.137.250:5000
</span></span><span style=display:flex><span>curl: (56) Recv failure: Connection reset by peer
</span></span></code></pre></div><h2 id=issue-4-conntrack>Issue 4: <code>conntrack</code></h2><p>As mentioned earlier, when <code>bridge-nf-call-iptables=1</code>, packets crossing a bridge go through the iptables hooks. When a packet is sent from <code>192.168.137.248</code> to <code>192.168.137.250</code>, it is DNATed on the first hop (<code>br-lan137</code>) to <code>172.18.0.4</code>. On the way back, the packet first passes <code>br-mellanox</code>, then <code>br-lan137</code> again. Both passes across a bridge trigger iptables hooks, causing conntrack conflicts. Here’s the conntrack log:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo conntrack -E --output extended,id | grep 5000 
</span></span><span style=display:flex><span>   [NEW] ipv4     2 tcp      6 120 SYN_SENT src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 [UNREPLIED] src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 id=1952199411
</span></span><span style=display:flex><span> [UPDATE] ipv4     2 tcp      6 60 SYN_RECV src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 id=1952199411
</span></span><span style=display:flex><span> [UPDATE] ipv4     2 tcp      6 432000 ESTABLISHED src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 [ASSURED] id=1952199411
</span></span><span style=display:flex><span>    [NEW] ipv4     2 tcp      6 300 ESTABLISHED src=192.168.137.250 dst=192.168.137.248 sport=5000 dport=55094 [UNREPLIED] src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=19460 id=1724107866
</span></span><span style=display:flex><span>[DESTROY] ipv4     2 tcp      6 300 CLOSE src=192.168.137.250 dst=192.168.137.248 sport=5000 dport=55094 [UNREPLIED] src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=19460 id=1724107866
</span></span><span style=display:flex><span> [UPDATE] ipv4     2 tcp      6 10 CLOSE src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 [ASSURED] id=1952199411
</span></span></code></pre></div><p>Look at the first three lines: conntrack records a connection with <code>ORIGIN = 192.168.137.248:55094 => 192.168.137.250:5000</code>, <code>REPLY = 172.18.0.4:5000 => 192.168.137.248:55094</code>. When the packet exits the Docker bridge, is routed and comes out of <code>br-mellanox</code>, it is SNATed in POSTROUTING back to <code>192.168.137.250</code>. So far, everything is normal. But the fourth line is problematic: a new connection appears with <code>ORIGIN = 192.168.137.250:5000 => 192.168.137.248:55094</code>, <code>REPLY = 192.168.137.248:55094 => 192.168.137.250:19460</code>. Note that the source port has been rewritten to <code>19460</code>. Capturing packets inside the container confirms this:</p><p><img src=https://res.cloudinary.com/core2duoe6420/image/upload/v1762948869/posts/docker-host-bridge-network/docker-bridge-wireshark_jfeay6.png alt=wireshark></p><p>Once you understand how conntrack works, it’s not hard to see why the port is rewritten. In conntrack, src and dst are not interchangeable, so <code>192.168.137.248:55094 => 192.168.137.250:5000</code> and <code>192.168.137.250:5000 => 192.168.137.248:55094</code> are two distinct tuples. When the packet passes <code>br-lan137</code>, conntrack sees a brand-new connection. When conntrack creates a new connection, it also needs to insert a REPLY tuple, but the REPLY tuple for this ORIGIN already exists in the hash table. That conflict leads to the port rewrite. Since the client cannot match this packet to its existing socket (due to the changed port), it responds with RST. When this RST reaches <code>br-lan137</code>, the port is rewritten back to the “normal” <code>5000</code>, so the server receives a RST and in turn sends another RST, closing the connection.</p><p>With help from Cursor, I located the line of code that rewrites the source port <a href=https://github.com/torvalds/linux/blob/24172e0d79900908cf5ebf366600616d29c9b417/net/netfilter/nf_nat_core.c#L688>here</a>. Since no iptables NAT rule matches this packet, the <code>nf_nat_alloc_null_binding</code> logic is used. While researching, I also found <a href=https://blog.csdn.net/dog250/article/details/112691374>this article</a>, which is quite interesting.</p><p>The part that really puzzled me—and took another full day of reading, going back and forth with Cursor, and even using <code>bpftrace</code>—was this: why does the TCP handshake succeed, but as soon as data is sent, a new connection is created and the source port gets rewritten? After all, during the handshake <code>br-lan137</code> also sees <code>192.168.137.250:5000 => 192.168.137.248:55094</code>. Why wasn’t the port rewritten right then?</p><p>After reading <a href="https://thermalcircle.de/doku.php?id=blog:linux:connection_tracking_3_state_and_examples">this series on conntrack</a>, I finally understood. If conntrack considers the return handshake packet (<code>SYN+ACK</code>) INVALID, it won’t mark the connection (set <code>skb->_nfct</code>). Without a conntrack mark, the packet won’t be NATed. Conntrack does not drop INVALID packets by itself, and I didn’t have iptables rules dropping them either, so the packet passes through normally. Logging INVALID packets confirms this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo iptables -I FORWARD -m conntrack --ctstate INVALID  -i br-lan137 -j LOG --log-prefix &#34;CT INVALID OUT: &#34; --log-level 4
</span></span><span style=display:flex><span>$ journalctl -k | grep &#34;CT INVALID&#34; | grep 55094
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Nov 12 19:46:36 nas kernel: CT INVALID OUT: IN=br-lan137 OUT=br-lan137 PHYSIN=veth-lan137-1 PHYSOUT=veth5a44ead MAC=72:ff:6f:af:95:56:98:03:9b:c4:d3:04:08:00 SRC=192.168.137.250 DST=192.168.137.248 LEN=60 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=5000 DPT=55094 WINDOW=65160 RES=0x00 ACK SYN URGP=0
</span></span><span style=display:flex><span>Nov 12 19:46:36 nas kernel: CT INVALID OUT: IN=br-lan137 OUT=br-lan137 PHYSIN=veth-lan137-1 PHYSOUT=veth5a44ead MAC=72:ff:6f:af:95:56:98:03:9b:c4:d3:04:08:00 SRC=192.168.137.250 DST=192.168.137.248 LEN=40 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=5000 DPT=55094 WINDOW=0 RES=0x00 RST URGP=0
</span></span></code></pre></div><p>So, is it INVALID for conntrack to see a <code>SYN+ACK</code> without having seen the initial <code>SYN</code>? The answer is in <a href=https://github.com/torvalds/linux/blob/24172e0d79900908cf5ebf366600616d29c9b417/net/netfilter/nf_conntrack_proto_tcp.c><code>nf_conntrack_proto_tcp.c</code></a>. Look at this state transition table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define sNO TCP_CONNTRACK_NONE
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sSS TCP_CONNTRACK_SYN_SENT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sSR TCP_CONNTRACK_SYN_RECV
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sES TCP_CONNTRACK_ESTABLISHED
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sFW TCP_CONNTRACK_FIN_WAIT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sCW TCP_CONNTRACK_CLOSE_WAIT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sLA TCP_CONNTRACK_LAST_ACK
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sTW TCP_CONNTRACK_TIME_WAIT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sCL TCP_CONNTRACK_CLOSE
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sS2 TCP_CONNTRACK_SYN_SENT2
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sIV TCP_CONNTRACK_MAX
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sIG TCP_CONNTRACK_IGNORE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>...
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Packets marked as INVALID (sIV):
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	if we regard them as truly invalid packets
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> u8 tcp_conntracks[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>6</span>][TCP_CONNTRACK_MAX] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span><span style=color:#75715e>/* ORIGINAL */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 	     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sS2	*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*syn*/</span>	   { sSS, sSS, sIG, sIG, sIG, sIG, sIG, sSS, sSS, sS2 },
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#75715e>/* 	     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sS2	*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*synack*/</span> { sIV, sIV, sSR, sIV, sIV, sIV, sIV, sIV, sIV, sSR },
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sNO -&gt; sIV	Too late and no reason to do anything
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSS -&gt; sIV	Client can&#39;t send SYN and then SYN/ACK
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sS2 -&gt; sSR	SYN/ACK sent to SYN2 in simultaneous open
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSR -&gt; sSR	Late retransmitted SYN/ACK in simultaneous open
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sES -&gt; sIV	Invalid SYN/ACK packets sent by the client
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sFW -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCW -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sLA -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sTW -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCL -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#75715e>/* 	     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sS2	*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*ack*/</span>	   { sES, sIV, sES, sES, sCW, sCW, sTW, sTW, sCL, sIV },
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sNO -&gt; sES	Assumed.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSS -&gt; sIV	ACK is invalid: we haven&#39;t seen a SYN/ACK yet.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sS2 -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSR -&gt; sES	Established state is reached.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sES -&gt; sES	:-)
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sFW -&gt; sCW	Normal close request answered by ACK.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCW -&gt; sCW
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sLA -&gt; sTW	Last ACK detected (RFC5961 challenged)
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sTW -&gt; sTW	Retransmitted last ACK. Remain in the same state.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCL -&gt; sCL
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span></code></pre></div><p>Now it’s clear: for this flow, the initial state is <code>sNO</code>, since conntrack hasn’t seen anything before. Upon receiving <code>SYN+ACK</code>, the state transitions to <code>sIV</code> (INVALID). Subsequent data packets are pure <code>ACK</code>s; from <code>sNO</code>, an <code>ACK</code> transitions to <code>sES</code> (ESTABLISHED), which matches the conntrack log and results in a new connection state, which in turn triggers NAT and port rewriting.</p><h2 id=solution>Solution</h2><p>All of the above was mainly to understand the true root cause and the packet path, and to deepen my understanding of networking. Fixing the issue is actually straightforward: just tell conntrack not to track traffic on <code>br-lan137</code>. So during startup, run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -t raw -I PREROUTING <span style=color:#ae81ff>1</span> -i br-lan137 -j NOTRACK
</span></span></code></pre></div><p>With this, there’s no need to tweak <code>bridge-nf-call-iptables</code>, no need to modify Docker’s firewall rules, and no need to assign an IP to <code>br-lan137</code>. The bridged networking then works perfectly.</p><h2 id=conclusion>Conclusion</h2><p>This issue troubled me for two full days. At one point I almost thought I wouldn’t find the answer anytime soon, but in the end I managed to figure it out. Of course, I still don’t fully understand all the details of conntrack, netfilter, or nftables; I usually only dig into them when I run into a problem. But with tools like ChatGPT and Cursor, common problems can be pinpointed directly, and even for uncommon ones they provide useful ideas. When source code is available, they can help analyze it too, which makes learning far more efficient than before. While debugging this conntrack problem, the AI also helped me write some <code>bpftrace</code> scripts. I’ve long heard of eBPF’s power but had never used it—this time I finally got to try it. Even though eBPF wasn’t the key to the final insight, it really is a powerful tool.</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">TAGGED IN</span><br><a class="tag tag--primary tag--small" href=https://blog.hljin.net/en-us/tags/docker/>docker</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2025/11/flowtable-mac-issue/ data-tooltip="OpenWrt Hardware Flow Offload Causing MAC Address Caching" aria-label="NEXT: OpenWrt Hardware Flow Offload Causing MAC Address Caching"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2023/10/kotlin-coroutine-mysteries/ data-tooltip="Kotlin Coroutine Pitfalls Record" aria-label="PREVIOUS: Kotlin Coroutine Pitfalls Record"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=gitalk><noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript></div><script src=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript>(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}new Gitalk({clientID:"2d9c9d837f8496107211",clientSecret:"5a474517d0eb6d5abdb90ab9a31c2ba94f4f43b2",repo:"core2duoe6420.github.io",owner:"core2duoe6420",admin:["core2duoe6420"],id:"0518def054cdfd1d6e01b9947f813cde",...{distractionfreemode:!1,enablehotkey:!0,language:"zh-CN",pagerdirection:"first",perpage:10}}).render("gitalk")})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 Powered by Hugo with tranquilpeak. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2025/11/flowtable-mac-issue/ data-tooltip="OpenWrt Hardware Flow Offload Causing MAC Address Caching" aria-label="NEXT: OpenWrt Hardware Flow Offload Causing MAC Address Caching"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2023/10/kotlin-coroutine-mysteries/ data-tooltip="Kotlin Coroutine Pitfalls Record" aria-label="PREVIOUS: Kotlin Coroutine Pitfalls Record"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"><h4 id=about-card-name>Alex King</h4><div id=about-card-bio>Observing without evaluating is the highest form of human intelligence</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Human</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Shanghai</div></div></div><div id=cover style=background-image:url(https://res.cloudinary.com/core2duoe6420/image/upload/v1643905455/20220204002352_yqvhwd.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://blog.hljin.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script async crossorigin=anonymous defer src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>