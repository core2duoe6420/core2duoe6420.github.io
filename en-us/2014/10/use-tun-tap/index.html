<!doctype html><html lang=en-us><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Importing Packets into the Protocol Stack with tun/tap","datePublished":"2014-10-22T00:00:00Z","dateModified":"2014-10-22T00:00:00Z","author":{"@type":"Person","name":"Alex King","image":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.hljin.net\/en-us\/2014\/10\/use-tun-tap\/"},"publisher":{"@type":"Organization","name":"Alex King's blog","logo":{"@type":"ImageObject","url":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"}},"description":" This article is translated from Chinese to English by ChatGPT. There might be errors.\nI originally thought the reason the dorm PC couldn’t ping the lab PC was that there was a layer of NAT in between. After talking with Wu Bo yesterday, I realized there was actually no NAT; it was a firewall issue. The firewall should be dropping ICMP packets and all inbound TCP SYN packets, so an external machine cannot establish a TCP connection directly to the lab machine. After some discussion with Wu Bo, I got the idea to try to break through the restriction that the dorm machine cannot establish TCP connections to the lab machine.\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Alex King"><meta name=keywords content><meta name=description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

I originally thought the reason the dorm PC couldn’t ping the lab PC was that there was a layer of NAT in between. After talking with Wu Bo yesterday, I realized there was actually no NAT; it was a firewall issue. The firewall should be dropping ICMP packets and all inbound TCP SYN packets, so an external machine cannot establish a TCP connection directly to the lab machine. After some discussion with Wu Bo, I got the idea to try to break through the restriction that the dorm machine cannot establish TCP connections to the lab machine."><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

I originally thought the reason the dorm PC couldn’t ping the lab PC was that there was a layer of NAT in between. After talking with Wu Bo yesterday, I realized there was actually no NAT; it was a firewall issue. The firewall should be dropping ICMP packets and all inbound TCP SYN packets, so an external machine cannot establish a TCP connection directly to the lab machine. After some discussion with Wu Bo, I got the idea to try to break through the restriction that the dorm machine cannot establish TCP connections to the lab machine."><meta property="og:type" content="article"><meta property="og:title" content="Importing Packets into the Protocol Stack with tun/tap"><meta name=twitter:title content="Importing Packets into the Protocol Stack with tun/tap"><meta property="og:url" content="https://blog.hljin.net/en-us/2014/10/use-tun-tap/"><meta property="twitter:url" content="https://blog.hljin.net/en-us/2014/10/use-tun-tap/"><meta property="og:site_name" content="Alex King's blog"><meta property="og:description" content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

I originally thought the reason the dorm PC couldn’t ping the lab PC was that there was a layer of NAT in between. After talking with Wu Bo yesterday, I realized there was actually no NAT; it was a firewall issue. The firewall should be dropping ICMP packets and all inbound TCP SYN packets, so an external machine cannot establish a TCP connection directly to the lab machine. After some discussion with Wu Bo, I got the idea to try to break through the restriction that the dorm machine cannot establish TCP connections to the lab machine."><meta name=twitter:description content="
  This article is translated from Chinese to English by ChatGPT. There might be errors.

I originally thought the reason the dorm PC couldn’t ping the lab PC was that there was a layer of NAT in between. After talking with Wu Bo yesterday, I realized there was actually no NAT; it was a firewall issue. The firewall should be dropping ICMP packets and all inbound TCP SYN packets, so an external machine cannot establish a TCP connection directly to the lab machine. After some discussion with Wu Bo, I got the idea to try to break through the restriction that the dorm machine cannot establish TCP connections to the lab machine."><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2014-10-22T00:00:00"><meta property="article:modified_time" content="2014-10-22T00:00:00"><meta name=twitter:card content="summary"><meta property="og:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><meta property="twitter:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><title>Importing Packets into the Protocol Stack with tun/tap</title><link rel=icon href=https://blog.hljin.net/favicon.png><link rel=canonical href=https://blog.hljin.net/en-us/2014/10/use-tun-tap/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://blog.hljin.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css><link rel=stylesheet href=https://blog.hljin.net/css/override.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://blog.hljin.net/en-us/ aria-label="Go to homepage">Alex King's blog</a></div><a class=header-right-picture href=https://blog.hljin.net/#about aria-label="Open the link: /#about"><img class=header-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://blog.hljin.net/#about aria-label="Read more about the author"><img class=sidebar-profile-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"></a><h4 class=sidebar-profile-name>Alex King</h4><h5 class=sidebar-profile-bio>Observing without evaluating is the highest form of human intelligence</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>Home</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>Categories</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>Tags</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/archives title=Archives><i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden=true></i>
<span class=sidebar-button-desc>Archives</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/en-us/#about title=About><i class="sidebar-button-icon fas fa-lg fa-user" aria-hidden=true></i>
<span class=sidebar-button-desc>About</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/core2duoe6420 target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>Importing Packets into the Protocol Stack with tun/tap</h1><div class="postShorten-meta post-meta"><time datetime=2014-10-22T00:00:00Z>October 22, 2014</time></div></div><div class="post-content markdown"><div class=main-content-wrap><div class="alert warning"><p>This article is translated from Chinese to English by ChatGPT. There might be errors.</p></div><p>I originally thought the reason the dorm PC couldn’t ping the lab PC was that there was a layer of NAT in between. After talking with Wu Bo yesterday, I realized there was actually no NAT; it was a firewall issue. The firewall should be dropping ICMP packets and all inbound <code>TCP SYN</code> packets, so an external machine cannot establish a TCP connection directly to the lab machine. After some discussion with Wu Bo, I got the idea to try to break through the restriction that the dorm machine cannot establish TCP connections to the lab machine.</p><p>The general idea is to send <code>TCP SYN</code> packets to the lab machine via some channel, and then inject those packets into the local protocol stack. This channel could be a third‑party server that connects to both the lab and dorm machines and acts as a relay. Our tests showed that the lab firewall does not block UDP packets, so we can simply use UDP to forward <code>TCP SYN</code> packets.</p><p>The key problem is injecting packets obtained at the application layer into the local protocol stack, so that the protocol stack on the lab machine will respond with a <code>TCP SYN ACK</code>. That packet will not be blocked by the firewall; moreover, once the firewall sees this packet it will create connection state, and subsequent packets will pass through the firewall. I had recently read about how OpenVPN implements <code>tun/tap</code>, which felt very similar, so I decided to try it.</p><p>For information on <code>tun/tap</code>, you can read this <a href=http://www.ibm.com/developerworks/cn/linux/l-tuntap/>article</a> from IBM; it’s quite good. As I understand it, after a process creates a <code>tun/tap</code> device, if you route a certain routing entry to that virtual device, then whenever a packet matches that route, the kernel will write the packet into the <code>tun/tap</code> device. This is equivalent to the sending path of <code>tun/tap</code>. The process that reads from the <code>tun/tap</code> device (since <code>tun/tap</code> is also implemented as a character device driver) will then obtain the packet that is about to be sent, and can process it and forward it via some other channel. OpenVPN, for example, encrypts the packet and then sends it over UDP. When the process writes to the <code>tun/tap</code> device, that is the receive path of <code>tun/tap</code>: the data written will be handed by the virtual NIC driver of <code>tun/tap</code> to the protocol stack as a normal packet. This is exactly what I need.</p><h2 id=environment>Environment</h2><p>Let me first describe the environment of the whole setup. The client is the dorm PC, running <code>Windows 7 x64</code>, using <code>WinPcap</code> for packet capture, compiled with <code>Visual C++ 2013(VC130)</code>, IP address <code>10.100.248.83</code>. The server is the lab PC, running <code>Ubuntu 14.04</code> (fortunately Linux; with Windows it could certainly be done too, but I don’t know how), IP address <code>10.10.90.192</code>, listening on UDP port 10000.</p><h2 id=getting-the-client-done-first>Getting the client done first</h2><p>The client side is easier to implement, so I’ll start there. Its main task is to use <code>WinPcap</code> to capture <code>TCP SYN</code> packets destined for the server, then encapsulate them in UDP and send them out. The code for filtering packets is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>pcap_compile</span>(fp, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>fcode, 
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;dst host 10.10.90.192 and tcp[tcpflags] &amp; (tcp-syn) != 0&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    netmask);
</span></span></code></pre></div><p>The sending code after capturing a packet is shown below. Since this is an experimental program, let’s not worry about performance or code elegance.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>packet_handler</span>(u_char <span style=color:#f92672>*</span> user, 
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> pcap_pkthdr <span style=color:#f92672>*</span> header,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> u_char <span style=color:#f92672>*</span> data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	SOCKET sockClient <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	SOCKADDR_IN addrServ;
</span></span><span style=display:flex><span>	addrServ.sin_addr.S_un.S_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(<span style=color:#e6db74>&#34;10.10.90.192&#34;</span>);
</span></span><span style=display:flex><span>	addrServ.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>	addrServ.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* The +14 and -14 below are for the case where the server uses tun,
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * because tun does not need the MAC layer, so we strip it.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * When using tap later, this can be removed.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sendto</span>(sockClient, (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)(data <span style=color:#f92672>+</span> <span style=color:#ae81ff>14</span>), 
</span></span><span style=display:flex><span>	        header<span style=color:#f92672>-&gt;</span>caplen <span style=color:#f92672>-</span> <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>	        (SOCKADDR<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addrServ, <span style=color:#66d9ef>sizeof</span>(SOCKADDR));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=tun-attempt-on-the-server>TUN attempt on the server</h2><p>The server side is a bit more complicated. My first thought was to use <code>tun</code>, because <code>tun</code> works at layer 3 and is conceptually simpler. Of course, much of the code is actually shared with <code>tap</code>. The code to open the <code>tun/tap</code> device was modeled after the IBM article above.</p><p>First is the code to open a <code>tun/tap</code> device. The type (<code>tap</code> vs <code>tun</code>) is distinguished by the <code>dev</code> name; the kernel uses the flags <code>IFF_TUN</code> and <code>IFF_TAP</code> to tell them apart:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>tun_creat</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> dev, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> actual, <span style=color:#66d9ef>int</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ifreq ifr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd, err;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;/dev/net/tun&#34;</span>, O_RDWR)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>ifr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(ifr));
</span></span><span style=display:flex><span>    ifr.ifr_flags <span style=color:#f92672>=</span> IFF_NO_PI;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strncmp</span>(dev, <span style=color:#e6db74>&#34;tun&#34;</span>, <span style=color:#ae81ff>3</span>)) {
</span></span><span style=display:flex><span>        ifr.ifr_flags <span style=color:#f92672>|=</span> IFF_TUN;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strncmp</span>(dev, <span style=color:#e6db74>&#34;tap&#34;</span>, <span style=color:#ae81ff>3</span>)) {
</span></span><span style=display:flex><span>        ifr.ifr_flags <span style=color:#f92672>|=</span> IFF_TAP;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Device %s illegal</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strlen</span>(dev) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((err <span style=color:#f92672>=</span> <span style=color:#a6e22e>ioctl</span>(fd, TUNSETIFF, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>ifr)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Cannot ioctl TUNSETIFF %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> err;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(actual, ifr.ifr_name, size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fd;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After creating the <code>tun/tap</code> device, you need to bring it up, which is equivalent to running <code>ip link set xxx up</code> in the shell, implemented by setting flags via <code>ioctl</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dev_bring_up</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> dev)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ifreq ifr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>ifr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> ifr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Get flags first, then set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(sockfd, SIOCGIFFLAGS, <span style=color:#f92672>&amp;</span>ifr) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Error up %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ifr.ifr_ifru.ifru_flags <span style=color:#f92672>|=</span> IFF_UP;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(sockfd, SIOCSIFFLAGS, <span style=color:#f92672>&amp;</span>ifr) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Error up %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Use these two functions to create and bring up a <code>tun</code> device:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tun;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> tun_name[IFNAMSIZ];
</span></span><span style=display:flex><span>    tun <span style=color:#f92672>=</span> <span style=color:#a6e22e>tun_creat</span>(<span style=color:#e6db74>&#34;tap10&#34;</span>, tun_name, <span style=color:#66d9ef>sizeof</span>(tun_name));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dev_bring_up</span>(tun_name);
</span></span></code></pre></div><p>Once the <code>tun</code> device is created and brought up, you can listen on the UDP port and write each received datagram entirely into the <code>tun</code> device:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in servaddr, cliaddr;
</span></span><span style=display:flex><span>    sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bzero</span>(<span style=color:#f92672>&amp;</span>servaddr, <span style=color:#66d9ef>sizeof</span>(servaddr));
</span></span><span style=display:flex><span>    servaddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    servaddr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>htonl</span>(INADDR_ANY);
</span></span><span style=display:flex><span>    servaddr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bind</span>(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>servaddr, <span style=color:#66d9ef>sizeof</span>(servaddr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> pkt[<span style=color:#ae81ff>1500</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> clilen <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(cliaddr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>recvfrom</span>(sockfd, pkt, <span style=color:#66d9ef>sizeof</span>(pkt), <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>                (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>cliaddr, <span style=color:#f92672>&amp;</span>clilen);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>calc_checksum</span>(pkt, n);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* The following line needs to be uncommented later when using tap.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * mac is a 6‑byte char array that should be declared earlier.
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//memcpy(pkt, mac, 6);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>write</span>(tun, pkt, n);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Here, the <code>calc_checksum</code> function is used to compute the IP checksum and TCP checksum. The client machine is very likely to have various offload features enabled, delegating checksum computation to the NIC. Therefore, the packets captured by WinPcap may not have checksums calculated. We need to compute them ourselves to ensure the protocol stack will accept the packets.</p><p>At this point, the program is roughly in place. After running it and capturing with Wireshark, I found that the <code>tun</code> virtual device is indeed receiving packets, but the protocol stack is not responding with <code>TCP SYN ACK</code> packets as expected. I don’t fully understand the underlying reason, but my guess is that the IP address <code>10.10.90.192</code> is configured on the <code>eth0</code> interface, so although this IP address is indeed a local NIC address, the protocol stack will not accept packets destined for it that arrive on a different interface.</p><h2 id=using-tap>Using tap</h2><p>Since <code>tun</code> doesn’t work, we have to consider <code>tap</code>. The advantage of using <code>tap</code> is that it emulates a full Ethernet NIC. The Linux kernel supports virtual bridge devices, so if we attach both <code>eth0</code> and the virtual <code>tap</code> to a bridge interface <code>br0</code>, and assign the IP address <code>10.10.90.192</code> to the bridge <code>br0</code>, then packets received by <code>tap</code> can be forwarded to <code>br0</code>. This makes the destination IP match the actual IP, so the protocol stack should accept the packets.</p><p>First, create a bridge with the <code>brctl</code> command in the shell:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brctl addbr br0                 <span style=color:#75715e># create a bridge</span>
</span></span><span style=display:flex><span>brctl addif br0 eth0            <span style=color:#75715e># add eth0 to the bridge first</span>
</span></span><span style=display:flex><span>ifconfig br0 10.10.90.192 up    <span style=color:#75715e># bring up br0 and assign IP</span>
</span></span><span style=display:flex><span>ifconfig eth0 0.0.0.0           <span style=color:#75715e># eth0 no longer needs an IP address</span>
</span></span></code></pre></div><p>Then in the code, after creating and bringing up <code>tap10</code>, add it to the bridge. I take a shortcut here and just use <code>system</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;brctl addif br0 tap10&#34;</span>);
</span></span></code></pre></div><p>Adjust all IP header offsets in the code. The last issue to solve is that before writing the packet to <code>tap</code>, we need to modify the destination MAC address in the Ethernet header to the MAC address of the bridge. Otherwise, if the destination MAC does not match the bridge’s MAC, the bridge will not accept the packet. To obtain the MAC address of a network device, use <code>ioctl</code> with <code>SIOCGIFHWADDR</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* mac should be a buffer of at least 6 bytes */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dev_get_mac</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> dev, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> mac)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ifreq ifr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>ifr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> ifr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(sockfd, SIOCGIFHWADDR, <span style=color:#f92672>&amp;</span>ifr) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Error get mac %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(mac, <span style=color:#f92672>&amp;</span>ifr.ifr_hwaddr.sa_data, <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This time, after compiling and running, the result is exactly as I expected: the dorm PC and the server PC can successfully establish a TCP connection. The experiment is a success.</p><p>Finally, a few notes about using virtual bridges. After <code>br0</code> is created, many settings that were originally attached directly to <code>eth0</code> must be moved to <code>br0</code>. For example, the original default route was:</p><pre><code>default via 10.10.90.1 dev eth0
</code></pre><p>Now it needs to be changed to:</p><pre><code>default via 10.10.90.1 dev br0
</code></pre><p>Previously, when I used OpenVPN to do NAT, the setting was:</p><pre><code>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE
</code></pre><p>Now it has to be changed to:</p><pre><code>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o br0 -j MASQUERADE
</code></pre><p>Because the original <code>eth0</code> no longer has an address, the result of <code>MASQUERADE</code> would otherwise be empty, and NAT would not be performed.</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2014/12/regular-expression/ data-tooltip="Summary of Learning Regular Expressions" aria-label="NEXT: Summary of Learning Regular Expressions"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2014/10/compile-wireshark/ data-tooltip="Compiling Wireshark on Windows" aria-label="PREVIOUS: Compiling Wireshark on Windows"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=gitalk><noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript></div><script src=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript>(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}new Gitalk({clientID:"2d9c9d837f8496107211",clientSecret:"5a474517d0eb6d5abdb90ab9a31c2ba94f4f43b2",repo:"core2duoe6420.github.io",owner:"core2duoe6420",admin:["core2duoe6420"],id:"5dd044a2443622d501c7878803f07933",...{distractionfreemode:!1,enablehotkey:!0,language:"zh-CN",pagerdirection:"first",perpage:10}}).render("gitalk")})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 Powered by Hugo with tranquilpeak. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2014/12/regular-expression/ data-tooltip="Summary of Learning Regular Expressions" aria-label="NEXT: Summary of Learning Regular Expressions"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">NEXT</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/en-us/2014/10/compile-wireshark/ data-tooltip="Compiling Wireshark on Windows" aria-label="PREVIOUS: Compiling Wireshark on Windows"><span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label="Share this post"><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label="Leave a comment"><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label="Back to top"><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt="Author's picture"><h4 id=about-card-name>Alex King</h4><div id=about-card-bio>Observing without evaluating is the highest form of human intelligence</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Human</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Shanghai</div></div></div><div id=cover style=background-image:url(https://res.cloudinary.com/core2duoe6420/image/upload/v1643905455/20220204002352_yqvhwd.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://blog.hljin.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script async crossorigin=anonymous defer src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>