<!doctype html><html lang=zh-cn><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker桥接宿主机网络","datePublished":"2025-11-11T00:00:00Z","dateModified":"2025-11-11T00:00:00Z","author":{"@type":"Person","name":"Alex King","image":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.hljin.net\/2025\/11\/docker-host-bridge-network\/"},"publisher":{"@type":"Organization","name":"Alex King's blog","logo":{"@type":"ImageObject","url":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"}},"description":"本文副标题为我的野路子Docker网络环境，主要介绍我在配置Docker桥接宿主机网络过程中遇到的坑。\nDocker的bridge网络是一个内部网络，与外界的通信都要通过三层路由和NAT转发，这在某些应用中不是很方便。而如果要桥接宿主机网络，最简单的方式是使用macvlan。但是macvlan有不能和宿主机通信的缺陷，并不是完美解。\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Alex King"><meta name=keywords content><meta name=description content="本文副标题为我的野路子Docker网络环境，主要介绍我在配置Docker桥接宿主机网络过程中遇到的坑。
Docker的bridge网络是一个内部网络，与外界的通信都要通过三层路由和NAT转发，这在某些应用中不是很方便。而如果要桥接宿主机网络，最简单的方式是使用macvlan。但是macvlan有不能和宿主机通信的缺陷，并不是完美解。"><meta property="og:description" content="本文副标题为我的野路子Docker网络环境，主要介绍我在配置Docker桥接宿主机网络过程中遇到的坑。
Docker的bridge网络是一个内部网络，与外界的通信都要通过三层路由和NAT转发，这在某些应用中不是很方便。而如果要桥接宿主机网络，最简单的方式是使用macvlan。但是macvlan有不能和宿主机通信的缺陷，并不是完美解。"><meta property="og:type" content="article"><meta property="og:title" content="Docker桥接宿主机网络"><meta name=twitter:title content="Docker桥接宿主机网络"><meta property="og:url" content="https://blog.hljin.net/2025/11/docker-host-bridge-network/"><meta property="twitter:url" content="https://blog.hljin.net/2025/11/docker-host-bridge-network/"><meta property="og:site_name" content="Alex King's blog"><meta property="og:description" content="本文副标题为我的野路子Docker网络环境，主要介绍我在配置Docker桥接宿主机网络过程中遇到的坑。
Docker的bridge网络是一个内部网络，与外界的通信都要通过三层路由和NAT转发，这在某些应用中不是很方便。而如果要桥接宿主机网络，最简单的方式是使用macvlan。但是macvlan有不能和宿主机通信的缺陷，并不是完美解。"><meta name=twitter:description content="本文副标题为我的野路子Docker网络环境，主要介绍我在配置Docker桥接宿主机网络过程中遇到的坑。
Docker的bridge网络是一个内部网络，与外界的通信都要通过三层路由和NAT转发，这在某些应用中不是很方便。而如果要桥接宿主机网络，最简单的方式是使用macvlan。但是macvlan有不能和宿主机通信的缺陷，并不是完美解。"><meta property="og:locale" content="zh-cn"><meta property="article:published_time" content="2025-11-11T00:00:00"><meta property="article:modified_time" content="2025-11-11T00:00:00"><meta property="article:tag" content="docker"><meta name=twitter:card content="summary"><meta property="og:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><meta property="twitter:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><title>Docker桥接宿主机网络</title><link rel=icon href=https://blog.hljin.net/favicon.png><link rel=canonical href=https://blog.hljin.net/2025/11/docker-host-bridge-network/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://blog.hljin.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css><link rel=stylesheet href=https://blog.hljin.net/css/override.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://blog.hljin.net/ aria-label=去首页>Alex King's blog</a></div><a class=header-right-picture href=https://blog.hljin.net/#about aria-label="打开链接: /#about"><img class=header-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://blog.hljin.net/#about aria-label=阅读有关作者的更多信息><img class=sidebar-profile-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片></a><h4 class=sidebar-profile-name>Alex King</h4><h5 class=sidebar-profile-bio>Observing without evaluating is the highest form of human intelligence</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>首页</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>分类</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>标签</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/archives title=Archives><i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden=true></i>
<span class=sidebar-button-desc>归档</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/#about title=About><i class="sidebar-button-icon fas fa-lg fa-user" aria-hidden=true></i>
<span class=sidebar-button-desc>关于</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/core2duoe6420 target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>Docker桥接宿主机网络</h1><div class="postShorten-meta post-meta"><time datetime=2025-11-11T00:00:00Z>十一月 11, 2025</time></div></div><div class="post-content markdown"><div class=main-content-wrap><p>本文副标题为我的野路子Docker网络环境，主要介绍我在配置Docker桥接宿主机网络过程中遇到的坑。</p><p>Docker的bridge网络是一个内部网络，与外界的通信都要通过三层路由和NAT转发，这在某些应用中不是很方便。而如果要桥接宿主机网络，最简单的方式是使用macvlan。但是macvlan有不能和宿主机通信的缺陷，并不是完美解。</p><p>我的宿主机有多块网卡，所以很早就把这些网卡都配置进了一个bridge里，就像OpenWRT里的<code>br-lan</code>那样，这为我绕过macvlan的限制提供了条件。思路也很简单，macvlan不能直接和宿主机通信，那我就新建一对veth，一个加进宿主机bridge，另一个作为macvlan的parent，这样macvlan不能和veth通信也无所谓。这个方案在绝大多数情况下工作地很好，我的HomeAssistant和UniFi-Controller用的都是这个方案。</p><p>看过我之前DSM那篇文章的读者会知道，我还有一个WebVirtCloud，我希望在容器里的虚拟机也可以桥接到宿主网络中，这时候macvlan就傻眼了，因为macvlan虚拟出来的子接口不能再被放进bridge里，也就是不能桥接。为了解决问题，我的方案是再创建一个Docker网络，然后生成一对veth，分别加入到主bridge和新的Docker bridge，然后在容器启动之后，手动修改IP地址和默认路由。这个方案很野，需要容器有NET_ADMIN的CAP，而且要写脚本配置IP，但是能用。</p><p>回想起来，当时操作这个方案的时候就遇到了本文想要介绍的问题，但是当时不知怎么想到的解决方案，总之就是解决了，但是没有彻底搞明白，也没有记录下来，导致我今天又重新栽了一遍跟头。</p><p>事情是这样的，之前的野路子是因为我没有找到让Docker直接用上已经创建好的bridge的办法。这两天心血来潮又搜了一下，发现了<a href=https://github.com/moby/libnetwork/issues/2310>这个Issue</a>，这两年Docker也有进步，好像可以支持使用已有的bridge了，于是就试了下，然后又遇到了奇怪的网络问题。</p><p>首先用netplan（我的宿主机是Ubuntu 24.04）定义bridge和veth，大致如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>network</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>version</span>: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>bridges</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这是我的宿主机bridge，省略了无关内容</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>br-mellanox</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>addresses</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>192.168.137.250</span><span style=color:#ae81ff>/24</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>interfaces</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>eno1</span>
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>veth-lan137-2</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>nameservers</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>addresses</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ae81ff>192.168.137.245</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>search</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ae81ff>hljin.net</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>routes</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>to</span>: <span style=color:#ae81ff>default</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>via</span>: <span style=color:#ae81ff>192.168.137.245</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这是给容器桥接用的</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>br-lan137</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>interfaces</span>:
</span></span><span style=display:flex><span>        - <span style=color:#ae81ff>veth-lan137-1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>virtual-ethernets</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>veth-lan137-1</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>peer</span>: <span style=color:#ae81ff>veth-lan137-2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>veth-lan137-2</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>peer</span>: <span style=color:#ae81ff>veth-lan137-1</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>ethernets</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>eno1</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>optional</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>dhcp4</span>: <span style=color:#66d9ef>false</span>
</span></span></code></pre></div><p>然后用以下命令创建Docker网络：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network create <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --driver bridge <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --subnet 192.168.137.0/24 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --gateway 192.168.137.245 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.enable_icc<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.enable_ip_masquerade<span style=color:#f92672>=</span>false <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.gateway_mode_ipv4<span style=color:#f92672>=</span>routed  <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.driver.mtu<span style=color:#f92672>=</span><span style=color:#ae81ff>1500</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.name<span style=color:#f92672>=</span>br-lan137 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -o com.docker.network.bridge.inhibit_ipv4<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    lan137
</span></span></code></pre></div><p>接下来在创建容器的时候指定网络<code>lan137</code>并且定好IP就好了，用docker-compose的话类似于：</p><pre tabindex=0><code>services:
  homeassistant:
    # 其它内容
    networks:
      lan137:
        ipv4_address: 192.168.137.248
networks:
  lan137:
    external: true
    name: lan137
</code></pre><p>启动之后就发现问题了，容器的网络基本通畅，和局域网内的设备都能通信，但唯独无法连接宿主机上通过Docker暴露的服务（就是普通Docker bridge的容器，通过<code>--publish</code>暴露的端口，大多数容器用的都是这个），例如<code>192.168.137.250:5000</code>，但是ping又是能ping通的。在ChatGPT的大力帮助下，花了一天时间研究这个问题。之所以会花这么长时间，是因为这个故障包含了四个小问题，甚至最后一个问题还没有完全弄明白。</p><h2 id=问题1bridge-nf-call-iptables>问题1：<code>bridge-nf-call-iptables</code></h2><p>在我的设想中，数据包经过<code>br-lan137</code>后，直接通过veth转发到<code>br-mellanox</code>上，然后进入宿主机网络栈，通过iptables DNAT到容器IP（网段为<code>172.18.0.0/16</code>）。但是因为<code>net.bridge.bridge-nf-call-iptables = 1</code>，所以这个数据包在<code>br-lan137</code>的时候就已经进入了iptables的处理流程中。这一点不难想到，但是我怀疑网络不通是因为防火墙的关系，一直在找和<code>br-lan137</code>相关的防火墙规则，怎么都找不到。后来才意识到，关键不是防火墙，而是进入iptables栈后，在<code>br-lan137</code>这里就直接触发了<code>PREROUTING</code>的<code>DNAT</code>，因为这条规则并不区分来源设备：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo iptables -t nat -L -n -v
</span></span><span style=display:flex><span>Chain PREROUTING (policy ACCEPT 928K packets, 63M bytes)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span> 5376  320K DOCKER     0    --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER (2 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>    0     0 RETURN     0    --  docker0 *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span> 1738  104K RETURN     0    --  br-da66fb6805df *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span> 1780  107K DNAT       6    --  !br-da66fb6805df *       0.0.0.0/0            0.0.0.0/0            tcp dpt:5000 to:172.18.0.4:5000
</span></span></code></pre></div><p>因此数据包在<code>br-lan137</code>就已经被DNAT到了<code>172.18.0.4</code>，并且出口设备应该是<code>br-da66fb6805df</code>。这也是为什么我找防火墙规则一直找不到的原因。</p><h2 id=问题2forward规则>问题2：<code>FORWARD</code>规则</h2><p>搞清问题1后，找到对应的防火墙规则并不难。为了方便阅读，精简了输出，只包含了重要部分：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo iptables -L -n -v
</span></span><span style=display:flex><span>Chain FORWARD (policy DROP 0 packets, 0 bytes)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>7238K 3417M DOCKER-FORWARD  0    --  *      *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER-FORWARD (1 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>6716K 3069M DOCKER-ISOLATION-STAGE-1  0    --  *      *       0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER-ISOLATION-STAGE-1 (1 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>  227 13620 DOCKER-ISOLATION-STAGE-2  0    --  br-lan137 !br-lan137  0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span> 631K   64M DOCKER-ISOLATION-STAGE-2  0    --  br-da66fb6805df !br-da66fb6805df  0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER-ISOLATION-STAGE-2 (3 references)
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     source               destination
</span></span><span style=display:flex><span>  218 13080 DROP       0    --  *      br-da66fb6805df  0.0.0.0/0            0.0.0.0/0
</span></span><span style=display:flex><span>    0     0 DROP       0    --  *      br-lan137  0.0.0.0/0            0.0.0.0/0
</span></span></code></pre></div><p>这些规则的主要目的就是Docker将不同的网络（也就是bridge）互相隔离。但是加入一条规则绕过iptables后，网络依旧不通，这就引出了第三个问题。</p><h2 id=问题3rp_filter>问题3：<code>rp_filter</code></h2><p><code>rp_filter</code>是为了确保数据包的SRC IP是本机可路由的IP，主要为了防止DDOS。默认的<code>rp_filter=2</code>，也就是比较宽松的策略，只需要SRC IP能通过本机的任意网口路由即可，那在我这个案例中，<code>192.168.137.0/24</code>本身就是宿主机网络，肯定是可以路由的，所以我一开始始终无法理解这个问题怎么就和<code>rp_filter</code>扯上关系。但是跑以下命令禁用<code>rp_filter</code>后，TCP就能握手成功了，所以不得不信：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sysctl -w net.ipv4.conf.all.rp_filter<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>sysctl -w net.ipv4.conf.br-lan137.rp_filter<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>后来ChatGPT提到了<code>fib_validate_source()</code>这个函数，顺藤摸瓜找到了<a href=https://github.com/centurycoder/martian_source>这篇文章</a>，这才明白不配IP的来源设备也会触发<code>rp_filter</code>，而在我的设想中<code>br-lan137</code>只是一个二层设备，不需要IP。</p><p>验证方法也很简单，随便给<code>br-lan137</code>加个IP即可，IP是啥不重要。</p><p>在解决防火墙和<code>rp_filter</code>之后，迎来了本次排障最难理解的地方，网络依旧不通，但症状变了，TCP可以成功握手，但是连接立刻就被reset掉：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span># telnet 192.168.137.250 5000
</span></span><span style=display:flex><span>Connected to 192.168.137.250
</span></span><span style=display:flex><span>^C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># curl http://192.168.137.250:5000
</span></span><span style=display:flex><span>curl: (56) Recv failure: Connection reset by peer
</span></span></code></pre></div><h2 id=问题4conntrack>问题4：<code>conntrack</code></h2><p>前面提到，<code>bridge-nf-call-iptables=1</code>会导致数据包在经过bridge的时候调用iptables hooks，当包从<code>192.168.137.248</code>发往<code>192.168.137.250</code>的时候，它在第一跳<code>br-lan137</code>就被DNAT到了<code>172.18.0.4</code>，但是返回的时候，还是会先经过<code>br-mellanox</code>，再到<code>br-lan137</code>，两次经过bridge都会调用iptables hook，然后就引起了conntrack冲突，以下是conntrack的日志：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo conntrack -E --output extended,id | grep 5000 
</span></span><span style=display:flex><span>   [NEW] ipv4     2 tcp      6 120 SYN_SENT src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 [UNREPLIED] src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 id=1952199411
</span></span><span style=display:flex><span> [UPDATE] ipv4     2 tcp      6 60 SYN_RECV src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 id=1952199411
</span></span><span style=display:flex><span> [UPDATE] ipv4     2 tcp      6 432000 ESTABLISHED src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 [ASSURED] id=1952199411
</span></span><span style=display:flex><span>    [NEW] ipv4     2 tcp      6 300 ESTABLISHED src=192.168.137.250 dst=192.168.137.248 sport=5000 dport=55094 [UNREPLIED] src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=19460 id=1724107866
</span></span><span style=display:flex><span>[DESTROY] ipv4     2 tcp      6 300 CLOSE src=192.168.137.250 dst=192.168.137.248 sport=5000 dport=55094 [UNREPLIED] src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=19460 id=1724107866
</span></span><span style=display:flex><span> [UPDATE] ipv4     2 tcp      6 10 CLOSE src=192.168.137.248 dst=192.168.137.250 sport=55094 dport=5000 src=172.18.0.4 dst=192.168.137.248 sport=5000 dport=55094 [ASSURED] id=1952199411
</span></span></code></pre></div><p>先看前3行输出，conntrack记录了<code>ORIGIN = 192.168.137.248:55094 => 192.168.137.250:5000</code>，<code>REPLY = 172.18.0.4:5000 => 192.168.137.248:55094</code>的连接。在数据包从Docker bridge出来经过3层路由从<code>br-mellanox</code>出来，在POSTROUTING里被SNAT回<code>192.168.137.250</code>，到这里一切正常。但第4条就不正常了，出现一条<code>ORIGIN = 192.168.137.250:5000 => 192.168.137.248:55094</code>，<code>REPLY = 192.168.137.248:55094 => 192.168.137.250:19460</code>的连接，可以看到源端口被改写为了<code>19460</code>，在容器内抓包可以验证这一点：</p><p><img src=https://res.cloudinary.com/core2duoe6420/image/upload/v1762948869/posts/docker-host-bridge-network/docker-bridge-wireshark_jfeay6.png alt=wireshark></p><p>在理解conntrack的工作原理后，想明白为啥这里的端口会被改写是不难的。conntrack里src和dst是不对易的，因此<code>192.168.137.248:55094 => 192.168.137.250:5000</code>和<code>192.168.137.250:5000 => 192.168.137.248:55094</code>是两个tuple，那么当数据包经过<code>br-lan137</code>时，conntrack看到的就是一条新连接，而conntrack在创建新连接时，需要同时插入REPLY的tuple，但这个ORIGIN对应的REPLY在哈希表中已经存在了，因此造成了冲突，于是有了这个奇怪的端口重写。而客户端在收到这个包后，当然匹配不到原本的socket，就会回应RST，这个RST包在抵达<code>br-lan137</code>后，又会被改写为正常的<code>5000</code>端口，于是一个RST包又被送到了服务端，服务端又发送了一个RST包结束连接，整条连接中断。</p><p>在Cursor的帮助下定位到了改写源端口的<a href=https://github.com/torvalds/linux/blob/24172e0d79900908cf5ebf366600616d29c9b417/net/netfilter/nf_nat_core.c#L688>这行代码</a>。因为并没有哪条iptables NAT规则匹配到了这个数据包，因此它走的是<code>nf_nat_alloc_null_binding</code>的逻辑。找资料的时候还找到了<a href=https://blog.csdn.net/dog250/article/details/112691374>这篇文章</a>，写得挺有意思。</p><p>这里真正让我百思不得其解，又花了整整一天时间查资料，和Cursor好几个来回，甚至用上了<code>bpftrace</code>的疑惑是：为什么TCP握手可以成功，但一发送数据就会创建一个新连接导致源端口被重写？明明在握手阶段<code>br-lan137</code>看到的也是<code>192.168.137.250:5000 => 192.168.137.248:55094</code>，为什么没有当时就直接被改写端口？</p><p>在看了<a href="https://thermalcircle.de/doku.php?id=blog:linux:connection_tracking_3_state_and_examples">这个关于conntrack的系列</a>后，我终于想明白了。如果conntrack在收到返回的握手数据包<code>SYN+ACK</code>后，认为这个数据包是INVALID的，那么就不会标记连接（也就是设置<code>skb->_nfct</code>），没有标记连接就不会被NAT，而conntrack并不会直接丢弃INVALID数据包，也没有iptables规则丢弃，因此这个包正常通行了。在尝试对INVALID数据包进行记录后也证实了这一点：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ sudo iptables -I FORWARD -m conntrack --ctstate INVALID  -i br-lan137 -j LOG --log-prefix &#34;CT INVALID OUT: &#34; --log-level 4
</span></span><span style=display:flex><span>$ journalctl -k | grep &#34;CT INVALID&#34; | grep 55094
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Nov 12 19:46:36 nas kernel: CT INVALID OUT: IN=br-lan137 OUT=br-lan137 PHYSIN=veth-lan137-1 PHYSOUT=veth5a44ead MAC=72:ff:6f:af:95:56:98:03:9b:c4:d3:04:08:00 SRC=192.168.137.250 DST=192.168.137.248 LEN=60 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=5000 DPT=55094 WINDOW=65160 RES=0x00 ACK SYN URGP=0
</span></span><span style=display:flex><span>Nov 12 19:46:36 nas kernel: CT INVALID OUT: IN=br-lan137 OUT=br-lan137 PHYSIN=veth-lan137-1 PHYSOUT=veth5a44ead MAC=72:ff:6f:af:95:56:98:03:9b:c4:d3:04:08:00 SRC=192.168.137.250 DST=192.168.137.248 LEN=40 TOS=0x00 PREC=0x00 TTL=63 ID=0 DF PROTO=TCP SPT=5000 DPT=55094 WINDOW=0 RES=0x00 RST URGP=0
</span></span></code></pre></div><p>那么在conntrack没有看到<code>SYN</code>的情况下，直接看到<code>SYN+ACK</code>是不是INVALID的呢？答案在<a href=https://github.com/torvalds/linux/blob/24172e0d79900908cf5ebf366600616d29c9b417/net/netfilter/nf_conntrack_proto_tcp.c><code>nf_conntrack_proto_tcp.c</code></a>里，看这个状态转移表：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define sNO TCP_CONNTRACK_NONE
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sSS TCP_CONNTRACK_SYN_SENT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sSR TCP_CONNTRACK_SYN_RECV
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sES TCP_CONNTRACK_ESTABLISHED
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sFW TCP_CONNTRACK_FIN_WAIT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sCW TCP_CONNTRACK_CLOSE_WAIT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sLA TCP_CONNTRACK_LAST_ACK
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sTW TCP_CONNTRACK_TIME_WAIT
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sCL TCP_CONNTRACK_CLOSE
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sS2 TCP_CONNTRACK_SYN_SENT2
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sIV TCP_CONNTRACK_MAX
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define sIG TCP_CONNTRACK_IGNORE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>...
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Packets marked as INVALID (sIV):
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	if we regard them as truly invalid packets
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> u8 tcp_conntracks[<span style=color:#ae81ff>2</span>][<span style=color:#ae81ff>6</span>][TCP_CONNTRACK_MAX] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span><span style=color:#75715e>/* ORIGINAL */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* 	     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sS2	*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*syn*/</span>	   { sSS, sSS, sIG, sIG, sIG, sIG, sIG, sSS, sSS, sS2 },
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#75715e>/* 	     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sS2	*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*synack*/</span> { sIV, sIV, sSR, sIV, sIV, sIV, sIV, sIV, sIV, sSR },
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sNO -&gt; sIV	Too late and no reason to do anything
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSS -&gt; sIV	Client can&#39;t send SYN and then SYN/ACK
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sS2 -&gt; sSR	SYN/ACK sent to SYN2 in simultaneous open
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSR -&gt; sSR	Late retransmitted SYN/ACK in simultaneous open
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sES -&gt; sIV	Invalid SYN/ACK packets sent by the client
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sFW -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCW -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sLA -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sTW -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCL -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#75715e>/* 	     sNO, sSS, sSR, sES, sFW, sCW, sLA, sTW, sCL, sS2	*/</span>
</span></span><span style=display:flex><span><span style=color:#75715e>/*ack*/</span>	   { sES, sIV, sES, sES, sCW, sCW, sTW, sTW, sCL, sIV },
</span></span><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sNO -&gt; sES	Assumed.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSS -&gt; sIV	ACK is invalid: we haven&#39;t seen a SYN/ACK yet.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sS2 -&gt; sIV
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sSR -&gt; sES	Established state is reached.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sES -&gt; sES	:-)
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sFW -&gt; sCW	Normal close request answered by ACK.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCW -&gt; sCW
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sLA -&gt; sTW	Last ACK detected (RFC5961 challenged)
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sTW -&gt; sTW	Retransmitted last ACK. Remain in the same state.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *	sCL -&gt; sCL
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span></code></pre></div><p>到这里就很清楚了，对这个数据包来说，初始状态是<code>sNO</code>，因为之前没有见过，那么在遇到<code>SYN+ACK</code>后，就变成了<code>sIV</code>，也就是INVALID。而之后发送的普通数据包只有<code>ACK</code>，在<code>sNO</code>的状态下转移到<code>sES</code>，也就是ESTABLISHED，符合上面的conntrack日志，从而有了一条连接，进而被NAT改写了端口。</p><h2 id=解决方案>解决方案</h2><p>上面写了这么多，其实是为了搞清楚真正的故障原因还有数据包链路，加深对网络的理解。而要解决这个问题其实很简单，让conntrack不要追踪<code>br-lan137</code>即可，所以启动的时候跑一下这条命令问题就解决了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -t raw -I PREROUTING <span style=color:#ae81ff>1</span> -i br-lan137 -j NOTRACK
</span></span></code></pre></div><p>不需要配置<code>bridge-nf-call-iptables</code>，不需要修改Docker的防火墙规则，也不需要给<code>br-lan137</code>配个IP地址，桥接网络完美运行。</p><h2 id=结束语>结束语</h2><p>这个问题困扰了我整整两天，差点就以为短时间内找不到答案了，好在最后还是都搞明白了。当然conntrack，乃至netfilter，nftables的细节，我依旧不懂，每次都是遇到问题了再去研究。不过现在有了ChatGPT和Cursor这样的工具，常见的问题AI能直接定位，不常见的问题也能给出一些思路，有了代码还能直接分析代码，学东西的效率要比以前高出太多了。在排查conntrack问题的过程中，AI还帮忙写了bpftrace脚本，一直久仰eBPF大名，但从没用过，这回也算尝鲜了，虽然最终想通问题并不是靠它，但确实是把利器。</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small" href=https://blog.hljin.net/tags/docker/>docker</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">下一篇</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2023/10/kotlin-coroutine-mysteries/ data-tooltip="Kotlin Coroutine踩坑记录" aria-label="上一篇: Kotlin Coroutine踩坑记录"><span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label=分享这个帖子><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label=发表评论><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label=回到顶部><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=gitalk><noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript></div><script src=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript>(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}new Gitalk({clientID:"2d9c9d837f8496107211",clientSecret:"5a474517d0eb6d5abdb90ab9a31c2ba94f4f43b2",repo:"core2duoe6420.github.io",owner:"core2duoe6420",admin:["core2duoe6420"],id:"0518def054cdfd1d6e01b9947f813cde",...{distractionfreemode:!1,enablehotkey:!0,language:"zh-CN",pagerdirection:"first",perpage:10}}).render("gitalk")})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2025 Powered by Hugo with tranquilpeak. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--disabled"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">下一篇</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2023/10/kotlin-coroutine-mysteries/ data-tooltip="Kotlin Coroutine踩坑记录" aria-label="上一篇: Kotlin Coroutine踩坑记录"><span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label=分享这个帖子><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label=发表评论><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label=回到顶部><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片><h4 id=about-card-name>Alex King</h4><div id=about-card-bio>Observing without evaluating is the highest form of human intelligence</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Human</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Shanghai</div></div></div><div id=cover style=background-image:url(https://res.cloudinary.com/core2duoe6420/image/upload/v1643905455/20220204002352_yqvhwd.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://blog.hljin.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script async crossorigin=anonymous defer src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>