<!doctype html><html lang=zh-cn><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BASH概念和常见语法","datePublished":"2017-09-30T00:00:00Z","dateModified":"2017-09-30T00:00:00Z","author":{"@type":"Person","name":"Alex King","image":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.hljin.net\/2017\/09\/bash-concept-and-syntax\/"},"publisher":{"@type":"Organization","name":"Alex King's blog","logo":{"@type":"ImageObject","url":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"}},"description":"本文是Bash用户手册的一个简要总结。\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Alex King"><meta name=keywords content><meta name=description content="本文是Bash用户手册的一个简要总结。"><meta property="og:description" content="本文是Bash用户手册的一个简要总结。"><meta property="og:type" content="article"><meta property="og:title" content="BASH概念和常见语法"><meta name=twitter:title content="BASH概念和常见语法"><meta property="og:url" content="https://blog.hljin.net/2017/09/bash-concept-and-syntax/"><meta property="twitter:url" content="https://blog.hljin.net/2017/09/bash-concept-and-syntax/"><meta property="og:site_name" content="Alex King's blog"><meta property="og:description" content="本文是Bash用户手册的一个简要总结。"><meta name=twitter:description content="本文是Bash用户手册的一个简要总结。"><meta property="og:locale" content="zh-cn"><meta property="article:published_time" content="2017-09-30T00:00:00"><meta property="article:modified_time" content="2017-09-30T00:00:00"><meta property="article:tag" content="Shell"><meta name=twitter:card content="summary"><meta property="og:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><meta property="twitter:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><title>BASH概念和常见语法</title><link rel=icon href=https://blog.hljin.net/favicon.png><link rel=canonical href=https://blog.hljin.net/2017/09/bash-concept-and-syntax/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://blog.hljin.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css><link rel=stylesheet href=https://blog.hljin.net/css/override.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://blog.hljin.net/ aria-label=去首页>Alex King's blog</a></div><a class=header-right-picture href=https://blog.hljin.net/#about aria-label="打开链接: /#about"><img class=header-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://blog.hljin.net/#about aria-label=阅读有关作者的更多信息><img class=sidebar-profile-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片></a><h4 class=sidebar-profile-name>Alex King</h4><h5 class=sidebar-profile-bio>Observing without evaluating is the highest form of human intelligence</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>首页</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>分类</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>标签</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/archives title=Archives><i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden=true></i>
<span class=sidebar-button-desc>归档</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/#about title=About><i class="sidebar-button-icon fas fa-lg fa-user" aria-hidden=true></i>
<span class=sidebar-button-desc>关于</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/core2duoe6420 target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>BASH概念和常见语法</h1><div class="postShorten-meta post-meta"><time datetime=2017-09-30T00:00:00Z>九月 30, 2017</time></div></div><div class="post-content markdown"><div class=main-content-wrap><p>本文是<a href=https://www.gnu.org/software/bash/manual/bash.html>Bash用户手册</a>的一个简要总结。</p><h1 id=table-of-contents>目录</h1><nav id=TableOfContents><ul><li><a href=#基础概念>基础概念</a></li><li><a href=#基础语法>基础语法</a><ul><li><a href=#循环>循环</a></li><li><a href=#条件>条件</a><ul><li><a href=#bash条件表达式bash扩展>Bash条件表达式（Bash扩展）</a></li></ul></li><li><a href=#函数>函数</a></li><li><a href=#特殊参数>特殊参数</a></li><li><a href=#展开>展开</a></li><li><a href=#重定向>重定向</a><ul><li><a href=#重定向语法>重定向语法</a></li></ul></li><li><a href=#数组和字典>数组和字典</a></li></ul></li><li><a href=#shell-builtin>Shell builtin</a></li><li><a href=#line-editing>Line Editing</a></li></ul></nav><h1 id=基础概念>基础概念</h1><ul><li><code>control operator</code>：用于控制方法（分割命令）：<code>newline</code> <code>||</code> <code>&&</code> <code>&</code> <code>;</code> <code>;;</code> <code>;&</code> <code>;;&</code> <code>|</code> <code>|&</code> <code>(</code> <code>)</code></li><li><code>metacharacter</code>：用于分割单词（<code>word</code>）：<code>|</code> <code>&</code> <code>;</code> <code>(</code> <code>)</code> <code>&lt;</code> <code>></code></li><li>Shell执行命令的过程如下：<ol><li>从文件或终端读入命令；</li><li>将输入分割成单词（<code>word</code>）和操作符（<code>operator</code>），这个步骤会应用转义规则（<code>Qouting</code>）。单词通过 <code>metacharacter</code>划分。同义展开（<code>alias expansion</code>）在这一步执行；</li><li>将词（<code>token</code>）解析为简单（<code>simple</code>）和复合（<code>compound</code>）命令；</li><li>执行各种展开（<code>expansion</code>)（展开顺序见下），将展开的词放入命令和参数中；</li><li>执行必要的重定向（<code>redirection</code>），从参数列表中去掉重定向操作符；</li><li>执行命令；</li><li>选择性的等待命令完成，获取退出状态。</li></ol></li><li>转义规则：<ul><li><code>\</code>转义下一个单词，<code>\newline</code>被认为行拼接，除非在<code>'</code>转义中，否则转义结果中<strong>不会</strong>出现换行（即<code>\n</code>）；</li><li><code>'</code>转义出现在引号内的所有字符；</li><li><code>"</code>转义转义除<code>$</code> <code>`</code> <code>\</code> <code>!</code>外所有字符。<code>$</code> <code>`</code>保持全有展开含义，<code>\</code>仅当后跟<code>$</code> <code>`</code> <code>"</code> <code>\</code> <code>newline</code>这些字符时才有转义语义，否则仍然输出反斜杠。若启用了历史展开，则<code>!</code>会展开，若<code>!</code>被<code>\</code>转义，则不会展开，并且<code>\</code>不会移除（仍然输出<code>\!</code>）；</li><li>ANSI-C转义，形如<code>$'\n'</code>通过ANSI C语义转义，如：<ul><li><code>\nnn</code>：8进制转义（最多3位）；</li><li><code>\xHH</code>：16进制转义（最多2位）；</li><li><code>\uHHHH</code>：Unicode转义（最多4位）；</li><li><code>\UHHHHHHHH</code>：Unicode转义（最多8位）；</li><li><code>\cx</code>：<code>control-x</code>转义。</li></ul></li></ul></li><li><code>|</code>和<code>|&</code>组成管道（<code>pipeline</code>），若在管道前加入<code>!</code>，则最终的exitcode被取反，如<code>! ls</code>（空格不能省略，否则被解析为历史展开），<code>|&</code>同时重定向<code>stdout</code>和<code>stderr</code>；</li><li><code>;</code> <code>&</code> <code>&&</code> <code>||</code>组成列表（<code>list</code>），并由<code>;</code> <code>&</code> <code>newline</code>表示结束，其中<code>&&</code> <code>||</code>优先级最高，<code>;</code> <code>&</code>其次。由<code>&</code>表示的命令在后台运行，若没有启用任务控制（<code>job control</code>），则进程的<code>stdin</code>会被重定向到<code>/dev/null</code>；</li><li><code>( list )</code>会创建一个subshell，然后执行命令，<code>{ list; }</code>会在当前shell执行命令，注意空格和<code>;</code>不能省略；</li><li><code>coproc</code>会创建一个coprocess；</li><li><code>parallel</code>与<code>xargs</code>类似，但是会并行执行命令；</li></ul><h1 id=基础语法>基础语法</h1><p>语法中的<code>;</code>大多可以被<code>newline</code>替换。</p><h2 id=循环>循环</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>until</span> test-commands; <span style=color:#66d9ef>do</span>      <span style=color:#75715e># 循环直到test-commands为0</span>
</span></span><span style=display:flex><span>	consequent-commands;
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> <span style=color:#75715e># exitcode是最后执行的命令的exitcode，如果没有任何语句执行则为0</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>while</span> test-commands; <span style=color:#66d9ef>do</span>     <span style=color:#75715e># 循环直到test-commands不为0</span>
</span></span><span style=display:flex><span>	consequent-commands;
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> <span style=color:#75715e># exitcode是最后执行的命令的exitcode，如果没有任何语句执行则为0</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>for</span> name <span style=color:#f92672>[</span> <span style=color:#f92672>[</span>in <span style=color:#f92672>[</span>words …<span style=color:#f92672>]</span> <span style=color:#f92672>]</span> ; <span style=color:#f92672>]</span> <span style=color:#66d9ef>do</span>  <span style=color:#75715e># in语句省略时，相当于in &#34;$@&#34;</span>
</span></span><span style=display:flex><span>	commands $name; 
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> <span style=color:#75715e># exitcode是最后执行的命令的exitcode，如果没有任何语句执行则为0</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>((</span> expr1 ; expr2 ; expr3 <span style=color:#f92672>))</span> ; <span style=color:#66d9ef>do</span>  <span style=color:#75715e># 应该是bash特有语法</span>
</span></span><span style=display:flex><span>	commands; 
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span> <span style=color:#75715e># exitcode是最后执行的命令的exitcode，如果任何expr非法，返回false</span>
</span></span></code></pre></div><h2 id=条件>条件</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>if</span> test-commands; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>	consequent-commands;
</span></span><span style=display:flex><span><span style=color:#66d9ef>elif</span> more-test-commands; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>	more-consequents;
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>	alternate-consequents;
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span> <span style=color:#75715e># exitcode是最后执行的命令的exitcode，如没有任何条件为真返回0</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>case</span> word in 
</span></span><span style=display:flex><span>	pattern1 | pattern2<span style=color:#f92672>)</span> command-list1 ;;  <span style=color:#75715e># ;;结尾若匹配直接返回</span>
</span></span><span style=display:flex><span>	pattern3 | pattern4<span style=color:#f92672>)</span> command-list2 ;&amp;  <span style=color:#75715e># ;&amp;结尾若匹配继续执行下一个command-list</span>
</span></span><span style=display:flex><span>	pattern5 | pattern6<span style=color:#f92672>)</span> command-list3 ;;&amp; <span style=color:#75715e># ;;&amp;结尾若匹配则继续匹配下一项，匹配成功则执行</span>
</span></span><span style=display:flex><span>	*<span style=color:#f92672>)</span> command-list ;;
</span></span><span style=display:flex><span><span style=color:#66d9ef>esac</span> <span style=color:#75715e># exitcode是执行的command-list的exitcode，若没有任何匹配则返回0</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>select</span> name <span style=color:#f92672>[</span>in words …<span style=color:#f92672>]</span>; <span style=color:#66d9ef>do</span> <span style=color:#75715e># 构造一个menu供用户选择</span>
</span></span><span style=display:flex><span>	commands $name $REPLY; <span style=color:#75715e># $REPLY表示序号</span>
</span></span><span style=display:flex><span>	break;                 <span style=color:#75715e># break退出select环境，否则会循环执行select</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>((</span> expression <span style=color:#f92672>))</span>  <span style=color:#75715e># bash算术表达式，若表达式非0，exitcode为0，否则exitcode为1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[[</span> expression <span style=color:#f92672>]]</span>  <span style=color:#75715e># bash条件表达式</span>
</span></span></code></pre></div><h3 id=bash条件表达式bash扩展>Bash条件表达式（Bash扩展）</h3><p>若没有特殊指定，则文件会跟踪符号连接，在目标文件上操作，而不是符号链接本身。</p><table><thead><tr><th>语法</th><th>含义</th></tr></thead><tbody><tr><td><code>-a file</code></td><td>若文件存在，返回真</td></tr><tr><td><code>-b file</code></td><td>若文件存在并且是块设备，返回真</td></tr><tr><td><code>-c file</code></td><td>若文件存在并且是字符设备，返回真</td></tr><tr><td><code>-d file</code></td><td>若文件存在并且是目录，返回真</td></tr><tr><td><code>-e file</code></td><td>若文件存在，返回真</td></tr><tr><td><code>-f file</code></td><td>若文件存在并且是普通文件，返回真</td></tr><tr><td><code>-g file</code></td><td>若文件存在并且<code>set-group-id</code>被设置，返回真</td></tr><tr><td><code>-h file</code></td><td>若文件存在并且是符号链接，返回真</td></tr><tr><td><code>-k file</code></td><td>若文件存在并且<code>sticky</code>被设置，返回真</td></tr><tr><td><code>-p file</code></td><td>若文件存在并且是命名管道（<code>FIFO</code>），返回真</td></tr><tr><td><code>-r file</code></td><td>若文件存在并且可读，返回真</td></tr><tr><td><code>-s file</code></td><td>若文件存在并且大小大于0，返回真</td></tr><tr><td><code>-t fd</code></td><td>若文件描述符打开并且指向终端，返回真</td></tr><tr><td><code>-u file</code></td><td>若文件存在并且<code>set-user-id</code>被设置，返回真</td></tr><tr><td><code>-w file</code></td><td>若文件存在并且可写，返回真</td></tr><tr><td><code>-x file</code></td><td>若文件存在并且可执行，返回真</td></tr><tr><td><code>-G file</code></td><td>若文件存在并且被当前<code>egid</code>拥有，返回真</td></tr><tr><td><code>-L file</code></td><td>若文件存在并且是符号链接，返回真</td></tr><tr><td><code>-N file</code></td><td>若文件存在并且自它上次被读取以来被修改过，返回真</td></tr><tr><td><code>-O file</code></td><td>若文件存在并且被当前<code>euid</code>拥有，返回真</td></tr><tr><td><code>-S file</code></td><td>若文件存在并且是<code>socket</code>，返回真</td></tr><tr><td><code>file1 -ef file2</code></td><td>若<code>file1</code>和<code>file2</code>指向相同的设备和<code>inode</code>号，返回真</td></tr><tr><td><code>file1 -nt file2</code></td><td>若<code>file1</code>比<code>file2</code>新（根据<code>mtime</code>）或者<code>file1</code>存在而<code>file2</code>不存在，返回真</td></tr><tr><td><code>file1 -ot file2</code></td><td>若<code>file1</code>比<code>file2</code>老（根据<code>mtime</code>）或者<code>file1</code>不存在而<code>file2</code>存在，返回真</td></tr><tr><td><code>-o optname</code></td><td>若shell选项<code>optname</code>打开，返回真</td></tr><tr><td><code>-v varname</code></td><td>若变量存在，返回真</td></tr><tr><td><code>-R varname</code></td><td>若变量存在，并且是一个引用（<code>name reference</code>），返回真</td></tr><tr><td><code>-z string</code></td><td>若字符串长度为0，返回真</td></tr><tr><td><code>-n string</code> <code>string</code></td><td>若字符串长度不为0，返回真</td></tr><tr><td><code>string1 == string2</code> <code>string1 = string2</code></td><td>若字符串相等，返回真。若在<code>[[</code>中使用，还可以进行模式匹配</td></tr><tr><td><code>string1 != string2</code></td><td>若字符串不等，返回真</td></tr><tr><td><code>string1 &lt; string2</code></td><td>若<code>string1</code>在字典序上排序比<code>string2</code>靠前，返回真</td></tr><tr><td><code>string1 > string2</code></td><td>若<code>string1</code>在字典序上排序比<code>string2</code>靠后，返回真</td></tr><tr><td><code>arg1 OP arg2</code></td><td><code>OP</code>可以是<code>-eq</code> <code>-ne</code> <code>-lt</code> <code>-le</code> <code>-gt</code> -<code>ge</code>。分别表示数字<code>arg1</code>比<code>arg2</code>相等、不等、小于、小于等于、大于、大于等于</td></tr></tbody></table><h2 id=函数>函数</h2><p>在函数中使用<code>local</code>语句定义局部变量</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>name <span style=color:#f92672>()</span> compound-command <span style=color:#f92672>[</span> redirections <span style=color:#f92672>]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 命令必须以; &amp; newline结尾</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> name <span style=color:#f92672>[()]</span> compound-command <span style=color:#f92672>[</span> redirections <span style=color:#f92672>]</span>
</span></span></code></pre></div><h2 id=特殊参数>特殊参数</h2><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>$*</code></td><td>从第一个到最后一个参数，<code>$*</code>会展开为<code>$1 $2 ...</code>，<code>"$*"</code>会展开<code>$1c$2c...</code>，其中<code>c</code>是<code>$IFS$</code></td></tr><tr><td><code>$@</code></td><td>从第一个到最后一个参数，<code>$@</code>会展开为<code>$1 $2 ...</code>，<code>"$@"</code>会展开为<code>"$1" "$2" ...</code>，若没有参数则<code>$@</code>会被移除</td></tr><tr><td><code>$#</code></td><td>参数数量</td></tr><tr><td><code>$?</code></td><td>最近执行的<strong>前台管道</strong>的exitcode</td></tr><tr><td><code>$-</code></td><td>当前shell的选项标志（通过<code>set</code>设置）</td></tr><tr><td><code>$$</code></td><td>当前shell的<code>pid</code>，在subshell中，<code>$$</code>展开为调用shell的<code>pid</code></td></tr><tr><td><code>$!</code></td><td>最近放入后台运行的job的<code>pid</code></td></tr><tr><td><code>$0</code></td><td>程序运行的名字（有疑点）</td></tr><tr><td><code>$_</code></td><td>上一个执行的命令的最后一个参数（有疑点）</td></tr></tbody></table><h2 id=展开>展开</h2><p>Shell展开通过以下顺序进行：</p><ol><li>括号展开（<code>brace expansion</code>）；</li><li>波浪号展开（<code>tilde expansion</code>），参数和变量展开（<code>parameter and variable expansion</code>），算数展开（<code>arithmetic expansion</code>），命令替换（<code>command substitution</code>），进程替换（<code>process substitution</code>），展开从左到右进行；</li><li>单词分割（<code>word splitting</code>）；</li><li>文件名展开（<code>filename expansion</code>，即wildcard）；</li><li>转义移除（<code>quote removal</code>）。</li></ol><p>各种展开语法：</p><table><thead><tr><th><div style=width:150px>展开类型</div></th><th>语法</th></tr></thead><tbody><tr><td>括号展开</td><td><code>a{b,c,d}e</code> <code>{x..y[..incr]}</code> 注意<code>,</code>前后不能有空格，<code>x</code> <code>y</code>可以是数字或者单个字符</td></tr><tr><td>波浪号展开</td><td><code>~</code>展开为<code>$HOME</code>，<code>~+</code>展开为<code>$PWD</code>，<code>~-</code>展开为<code>$OLDPWD</code>，<code>~N ~+N ~-N</code>展开为<code>`dirs +/-N`</code></td></tr><tr><td>参数展开</td><td><code>${parameter}</code></td></tr><tr><td>算数展开</td><td><code>$(( expression ))</code></td></tr><tr><td>命令替换</td><td><code>$(command)</code> <code>`command`</code> 使用<code>$()</code>语法时，所有字符保持原有语义，没有任何特殊字符，使用反引号语法时，<code>$</code> <code>`</code> <code>\</code>有特殊语义，可以被<code>\</code>转义</td></tr><tr><td>进程替换</td><td><code>&lt;(list)</code> <code>>(list)</code>，注意尖括号与圆括号之间不能有空格</td></tr><tr><td>文件名展开</td><td><code>*</code> <code>?</code> <code>[...]</code></td></tr></tbody></table><p>参数展开的格式：</p><ul><li><code>${parameter:-word}</code>：若<code>paramter</code>没有设置，则展开<code>word</code>，否则展开<code>parameter</code>；</li><li><code>${parameter:=word}</code>：若<code>paramter</code>没有设置，则将<code>word</code>展开后的值赋给<code>parameter</code>，然后展开；</li><li><code>${parameter:?word}</code>：若<code>parameter</code>没有设置，则将<code>word</code>展开后输出到<code>stderr</code>，若shell不是交互式的则退出；</li><li><code>${parameter:+word}</code>：若<code>parameter</code>没有设置，不替换任何值，否则替换为<code>word</code>的展开；</li><li><code>${parameter:offset}</code> <code>${parameter:offset:length}</code>：取<code>parameter</code>的子字符串。<code>offset</code>和<code>length</code>为负数时，表示从字符串末端向前数的第n个字符，<code>offset</code>为负数时，<code>:</code>和<code>-</code>之间必须有空格；</li><li><code>${!prefix*}</code> <code>${!prefix@}</code>：将变量名以<code>prefix</code>开头的变量展开，并通过<code>$IFS</code>连结；</li><li><code>${!name[@]}</code> <code>${!name[*]}</code>：若<code>name</code>是数组（或字典），则展开为下标（或键值），如果不是，若<code>name</code>已定义，则展开为0，否则为<code>null</code>，如果使用<code>@</code>，则每个键值被展开为单独的<code>"</code>转义的词；</li><li><code>${#parameter}</code>：展开为数组长度；</li><li><code>${parameter#word}</code>：将<code>parameter</code>从左边开始最短匹配<code>word</code>的部分删除后展开；</li><li><code>${parameter##word}</code>：将<code>parameter</code>从左边开始最长匹配<code>word</code>的部分删除后展开；</li><li><code>${parameter%word}</code>：将<code>parameter</code>从右边开始最短匹配<code>word</code>的部分删除后展开；</li><li><code>${parameter%%word}</code>：将<code>parameter</code>从右边开始最长匹配<code>word</code>的部分删除后展开；</li><li><code>${parameter/pattern/string}</code>：将<code>parameter</code>匹配<code>pattern</code>的部分替换为<code>string</code>后展开。<code>pattern</code>可以以以下字符开始：<ul><li><code>/</code>：表示所有的匹配都要替换，一般情况下只替换一次；</li><li><code>#</code>：匹配必须从开始位置匹配；</li><li><code>%</code>：必须匹配结束位置。</li></ul></li><li><code>${parameter^pattern}</code> <code>${parameter^^pattern}</code> <code>${parameter,pattern}</code> <code>${parameter,,pattern}</code>：查找<code>parameter</code>中匹配<code>pattern</code>的部分，并转换大小写，其中<code>^</code> <code>^^</code>将小写转换为大写，<code>,</code> <code>,,</code>将大写转换为小写，<code>^</code> <code>,</code>仅转换一次，<code>^^</code> <code>,,</code>转换全部。若<code>pattern</code>省略，则相当于匹配全部内容。</li></ul><p>文件名展开时，若<code>extglob</code>选项打开（通过<code>shopt</code>命令），则还支持以下命令语法：</p><ul><li><code>?(pattern-list)</code> 匹配0个或1个</li><li><code>*(pattern-list)</code> 匹配0个或多个</li><li><code>+(pattern-list)</code> 匹配1个或多个</li><li><code>@(pattern-list)</code> 匹配1个</li><li><code>!(pattern-list)</code> 匹配除pattern外的任何字符串</li></ul><h2 id=重定向>重定向</h2><p>Bash使用一些在重定向中的特殊文件，如果操作系统支持这些文件，Bash会使用操作系统提供的文件，如果不支持，则Bash会模拟相应的文件：</p><table><thead><tr><th>文件</th><th>含义</th></tr></thead><tbody><tr><td><code>/dev/fd/fd</code></td><td>复制<code>fd</code></td></tr><tr><td><code>/dev/stdin</code></td><td>标准输入</td></tr><tr><td><code>/dev/stdout</code></td><td>标准输出</td></tr><tr><td><code>/dev/stderr</code></td><td>标准错误</td></tr><tr><td><code>/dev/tcp/host/port</code></td><td>重定向到<code>tcp://host:port</code></td></tr><tr><td><code>/dev/udp/host/port</code></td><td>重定向到<code>udp://host:port</code></td></tr></tbody></table><h3 id=重定向语法>重定向语法</h3><table><thead><tr><th><div style=width:250px>语法</div></th><th>含义</th></tr></thead><tbody><tr><td><code>[n]&lt;word</code></td><td>重定向输入</td></tr><tr><td><code>[n]>[|]word</code></td><td>重定向输出，如果有<code>|</code>，则无视<code>noclobber</code>设置</td></tr><tr><td><code>[n]>>word</code></td><td>追加输出</td></tr><tr><td><code>&>word</code> <code>>&amp;word</code> <code>>word 2>&amp;1</code></td><td>同时重定向<code>stdout</code>和<code>stderr</code></td></tr><tr><td><code>&>>word</code> <code>>>word 2>&amp;1</code></td><td>同时追加<code>stdout</code>和<code>stderr</code></td></tr><tr><td><code>[n]&lt;&lt;[-]word<br>    here-document<br> delimiter</code></td><td><code>here document</code>，如果<code>word</code>被转义（被<code>'</code>括起），<code>delimiter</code>是转义后的<code>word</code>，并且不会展开<code>here-document</code>中的任何内容，如果<code>word</code>没有被转义，则<code>here-document</code>会进行参数和变量展开、命令替换和算数展开，<code>\</code>必须用于转义<code>\</code> <code>$</code> <code>`</code>。如果使用<code>&lt;&lt;-</code>，则<code>here-document</code>中的前导<code>tab</code>会被移除。</td></tr><tr><td><code>[n]&lt;&lt;&lt; word</code></td><td><code>here string</code>，<code>word</code>会经过括号展开、波浪号展开、参数和变量展开、命令替换、算数展开和转义移除，文件名展开和单词分割不会进行，结果中会追加一个新行。</td></tr><tr><td><code>[n]&lt;&amp;word</code> <code>[n]>&amp;word</code></td><td>复制文件描述符，如果<code>word</code>指定的描述符没有打开，则报错，如果<code>word</code>是<code>-</code>，则文件描述符<code>n</code>被关闭。</td></tr><tr><td><code>[n]&lt;&amp;digit-</code> <code>[n]>&amp;digit-</code></td><td>移动文件描述符，即复制后关闭<code>digit</code>。</td></tr><tr><td><code>[n]&lt;>word</code></td><td>打开<code>word</code>为文件描述符<code>n</code>用于读写，若<code>n</code>省略默认为0，若文件不存在，则会创建。</td></tr></tbody></table><h2 id=数组和字典>数组和字典</h2><p>定义数组：</p><ul><li><code>name[subscript]=value</code></li><li><code>declare -a name</code></li><li><code>name=(value1 value2 ... )</code></li></ul><p>定义字典：</p><ul><li><code>declare -A name</code></li></ul><p>引用数组或字典中的值：</p><ul><li><code>${name[subscript]}</code></li></ul><h1 id=shell-builtin>Shell builtin</h1><ul><li>使用<code>help cmd</code>获取Shell builtin的帮助；</li><li>使用<code>type cmd</code>可以查询<code>cmd</code>是否是Shell builtin；</li><li><code>trap</code>：设置信号处理程序。例子：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>trap <span style=color:#e6db74>&#34;echo SIGINT&#34;</span> <span style=color:#ae81ff>2</span>    <span style=color:#75715e># 为SIGINT设置处理程序</span>
</span></span><span style=display:flex><span>trap - <span style=color:#ae81ff>2</span>                <span style=color:#75715e># 清除处理程序</span>
</span></span></code></pre></div><h1 id=line-editing>Line Editing</h1><p>Bash使用<code>readline</code>控制行编辑。<code>readline</code>会尝试读取shell变量<code>INPUTRC</code>中指定的配置文件，若变量不存在，读取<code>~/.inputrc</code>，若该文件不存在，读取<code>/etc/inputrc</code>。</p><p>使用<code>bind -P</code>可以列出所有当前绑定的按键和操作，其中</p><ul><li><code>\C-x</code>表示<code>ctrl-x</code>；</li><li><code>\M-x</code>表示<code>Meta-x</code>，通常<code>Meta</code>键是<code>alt</code>键；</li><li><code>\C-\M-x</code>表示同时按下<code>ctrl</code>和<code>alt</code></li><li><code>\ex</code>表示<code>Esc-x</code>。</li></ul><p>使用<code>bind -V</code>列出当前设置。例如，使用<code>bind "set completion-disabled on"</code>可以禁用自动补全。</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-footer-tags><span class="text-color-light text-small">标签</span><br><a class="tag tag--primary tag--small" href=https://blog.hljin.net/tags/shell/>Shell</a></div><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2020/02/docker-dns-troubleshooting/ data-tooltip="记一次Docker DNS排障" aria-label="下一篇: 记一次Docker DNS排障"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">下一篇</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2016/06/effective-modern-cpp-excerpt/ data-tooltip="Effective Modern C++学习笔记" aria-label="上一篇: Effective Modern C++学习笔记"><span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label=分享这个帖子><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label=发表评论><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label=回到顶部><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=gitalk><noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript></div><script src=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript>(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}new Gitalk({clientID:"2d9c9d837f8496107211",clientSecret:"5a474517d0eb6d5abdb90ab9a31c2ba94f4f43b2",repo:"core2duoe6420.github.io",owner:"core2duoe6420",admin:["core2duoe6420"],id:"2b7e453505c477489eb1d9edde5220db",...{distractionfreemode:!1,enablehotkey:!0,language:"zh-CN",pagerdirection:"first",perpage:10}}).render("gitalk")})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2023 Powered by Hugo with tranquilpeak. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2020/02/docker-dns-troubleshooting/ data-tooltip="记一次Docker DNS排障" aria-label="下一篇: 记一次Docker DNS排障"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">下一篇</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2016/06/effective-modern-cpp-excerpt/ data-tooltip="Effective Modern C++学习笔记" aria-label="上一篇: Effective Modern C++学习笔记"><span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label=分享这个帖子><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label=发表评论><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label=回到顶部><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片><h4 id=about-card-name>Alex King</h4><div id=about-card-bio>Observing without evaluating is the highest form of human intelligence</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Human</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Shanghai</div></div></div><div id=cover style=background-image:url(https://res.cloudinary.com/core2duoe6420/image/upload/v1643905455/20220204002352_yqvhwd.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://blog.hljin.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script async crossorigin=anonymous defer src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>