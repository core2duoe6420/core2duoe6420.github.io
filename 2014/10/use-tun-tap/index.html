<!doctype html><html lang=zh-cn><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用tun/tap将数据包导入协议栈","datePublished":"2014-10-22T00:00:00Z","dateModified":"2014-10-22T00:00:00Z","author":{"@type":"Person","name":"Alex King","image":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.hljin.net\/2014\/10\/use-tun-tap\/"},"publisher":{"@type":"Organization","name":"Alex King's blog","logo":{"@type":"ImageObject","url":"https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"}},"description":"我原本以为寝室的电脑ping不通实验室的电脑是因为之间隔了一层NAT的关系，昨天听吴博说了才知道原来没有NAT，而是防火墙的关系。防火墙应该是丢弃了ICMP包和所有入站的TCP SYN包，所以外面的电脑无法通过TCP直接连接实验室电脑。跟吴博一番讨论后，萌发了尝试突破寝室电脑无法TCP连接到实验室电脑的限制。\n","keywords":[]}</script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.111.3 with theme Tranquilpeak 0.5.3-BETA"><meta name=author content="Alex King"><meta name=keywords content><meta name=description content="我原本以为寝室的电脑ping不通实验室的电脑是因为之间隔了一层NAT的关系，昨天听吴博说了才知道原来没有NAT，而是防火墙的关系。防火墙应该是丢弃了ICMP包和所有入站的TCP SYN包，所以外面的电脑无法通过TCP直接连接实验室电脑。跟吴博一番讨论后，萌发了尝试突破寝室电脑无法TCP连接到实验室电脑的限制。"><meta property="og:description" content="我原本以为寝室的电脑ping不通实验室的电脑是因为之间隔了一层NAT的关系，昨天听吴博说了才知道原来没有NAT，而是防火墙的关系。防火墙应该是丢弃了ICMP包和所有入站的TCP SYN包，所以外面的电脑无法通过TCP直接连接实验室电脑。跟吴博一番讨论后，萌发了尝试突破寝室电脑无法TCP连接到实验室电脑的限制。"><meta property="og:type" content="article"><meta property="og:title" content="使用tun/tap将数据包导入协议栈"><meta name=twitter:title content="使用tun/tap将数据包导入协议栈"><meta property="og:url" content="https://blog.hljin.net/2014/10/use-tun-tap/"><meta property="twitter:url" content="https://blog.hljin.net/2014/10/use-tun-tap/"><meta property="og:site_name" content="Alex King's blog"><meta property="og:description" content="我原本以为寝室的电脑ping不通实验室的电脑是因为之间隔了一层NAT的关系，昨天听吴博说了才知道原来没有NAT，而是防火墙的关系。防火墙应该是丢弃了ICMP包和所有入站的TCP SYN包，所以外面的电脑无法通过TCP直接连接实验室电脑。跟吴博一番讨论后，萌发了尝试突破寝室电脑无法TCP连接到实验室电脑的限制。"><meta name=twitter:description content="我原本以为寝室的电脑ping不通实验室的电脑是因为之间隔了一层NAT的关系，昨天听吴博说了才知道原来没有NAT，而是防火墙的关系。防火墙应该是丢弃了ICMP包和所有入站的TCP SYN包，所以外面的电脑无法通过TCP直接连接实验室电脑。跟吴博一番讨论后，萌发了尝试突破寝室电脑无法TCP连接到实验室电脑的限制。"><meta property="og:locale" content="zh-cn"><meta property="article:published_time" content="2014-10-22T00:00:00"><meta property="article:modified_time" content="2014-10-22T00:00:00"><meta name=twitter:card content="summary"><meta property="og:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><meta property="twitter:image" content="https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg"><title>使用tun/tap将数据包导入协议栈</title><link rel=icon href=https://blog.hljin.net/favicon.png><link rel=canonical href=https://blog.hljin.net/2014/10/use-tun-tap/><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha512-H9jrZiiopUdsLpg94A333EfumgUBpO9MdbxStdeITo+KEIMaNfHNvwyjjDJb+ERPaRS6DpyRlKbvPUasNItRyw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css integrity="sha512-MLcK/YRapzET1qTBXrOiZE6bGBgtATMo2bIyalVJ8EKDEGNoeA3SPQkvWAR0zNS650YG13ocXBMeioDuZcSRuQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://blog.hljin.net/css/style-h6ccsoet3mzkbb0wngshlfbaweimexgqcxj0h5hu4h82olsdzz6wmqdkajm.min.css><link rel=stylesheet href=https://blog.hljin.net/css/override.css></head><body><div id=blog><header id=header data-behavior=4><i id=btn-open-sidebar class="fa fa-lg fa-bars"></i><div class=header-title><a class=header-title-link href=https://blog.hljin.net/ aria-label=去首页>Alex King's blog</a></div><a class=header-right-picture href=https://blog.hljin.net/#about aria-label="打开链接: /#about"><img class=header-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片></a></header><nav id=sidebar data-behavior=4><div class=sidebar-container><div class=sidebar-profile><a href=https://blog.hljin.net/#about aria-label=阅读有关作者的更多信息><img class=sidebar-profile-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片></a><h4 class=sidebar-profile-name>Alex King</h4><h5 class=sidebar-profile-bio>Observing without evaluating is the highest form of human intelligence</h5></div><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/ title=Home><i class="sidebar-button-icon fas fa-lg fa-home" aria-hidden=true></i>
<span class=sidebar-button-desc>首页</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/categories title=Categories><i class="sidebar-button-icon fas fa-lg fa-bookmark" aria-hidden=true></i>
<span class=sidebar-button-desc>分类</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/tags title=Tags><i class="sidebar-button-icon fas fa-lg fa-tags" aria-hidden=true></i>
<span class=sidebar-button-desc>标签</span></a></li></ul><ul class=sidebar-buttons><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/archives title=Archives><i class="sidebar-button-icon fas fa-lg fa-archive" aria-hidden=true></i>
<span class=sidebar-button-desc>归档</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://blog.hljin.net/#about title=About><i class="sidebar-button-icon fas fa-lg fa-user" aria-hidden=true></i>
<span class=sidebar-button-desc>关于</span></a></li><li class=sidebar-button><a class=sidebar-button-link href=https://github.com/core2duoe6420 target=_blank rel=noopener title=GitHub><i class="sidebar-button-icon fab fa-lg fa-github" aria-hidden=true></i>
<span class=sidebar-button-desc>GitHub</span></a></li></ul><ul class=sidebar-buttons></ul></div></nav><div id=main data-behavior=4 class=hasCoverMetaIn><article class=post id=top><div class="post-header main-content-wrap text-left"><h1 class=post-title>使用tun/tap将数据包导入协议栈</h1><div class="postShorten-meta post-meta"><time datetime=2014-10-22T00:00:00Z>十月 22, 2014</time></div></div><div class="post-content markdown"><div class=main-content-wrap><p>我原本以为寝室的电脑ping不通实验室的电脑是因为之间隔了一层NAT的关系，昨天听吴博说了才知道原来没有NAT，而是防火墙的关系。防火墙应该是丢弃了ICMP包和所有入站的<code>TCP SYN</code>包，所以外面的电脑无法通过TCP直接连接实验室电脑。跟吴博一番讨论后，萌发了尝试突破寝室电脑无法TCP连接到实验室电脑的限制。</p><p>大致上的思路是通过某种渠道将<code>TCP SYN</code>数据包发到实验室电脑上，然后将数据包导入本机协议栈。这个渠道可以是一个第三方服务器，分别和实验室电脑和寝室电脑连接，作为一个中转站。因为我们测试后发现实验室防火墙没有封锁UDP数据包，所以直接用UDP来转发<code>TCP SYN</code>数据包。</p><p>问题的关键在于将应用层获得的数据包导入到本机协议栈，让实验室电脑的协议栈响应<code>TCP SYN ACK</code>握手包，这个包不会被防火墙拦截，而且防火墙在看到这个包之后会建立连接信息，之后的数据包就能顺利通过防火墙了。之前正好了解了一下OpenVPN关于<code>tun/tap</code>的实现原理，觉得非常相似，所以决定尝试一下。</p><p>有关<code>tun/tap</code>的资料，可以阅读IBM的这篇<a href=http://www.ibm.com/developerworks/cn/linux/l-tuntap/>文章</a>，讲的还是挺不错的。就我个人的理解，在进程创建了一个<code>tun/tap</code>设备后，如果将路由表中的某一项路由到该虚拟设备后，当有数据包满足该路由条目后，内核就会将该数据包写入到<code>tun/tap</code>设备，相当于<code>tun/tap</code>的发送过程，而此时读取该<code>tun/tap</code>设备（<code>tun/tap</code>也实现了字节设备驱动）的进程就能获得这个要发送的数据包，此时可以对数据包进行处理后再通过其他渠道发送出去，OpenVPN就是对数据包进行加密后，再用UDP发送出去。而当进程向<code>tun/tap</code>设备写入时，就是<code>tun/tap</code>设备的接收过程，写入的数据会被<code>tun/tap</code>设备的虚拟网卡驱动作为正常的数据包放入协议栈处理。这正是我需要的功能。</p><h2 id=环境>环境</h2><p>还是先介绍一下整个应用的环境，客户机是位于寝室的电脑，<code>Windows 7 x64</code>，使用<code>WinPcap</code>抓包，编译器是<code>Visual C++ 2013(VC130)</code>，IP地址<code>10.100.248.83</code>。服务器是位于实验室的电脑，<code>Ubuntu 14.04</code>（幸好是Linux，Windows的话虽然肯定也能做但我是不知道了），IP地址<code>10.10.90.192</code>，监听UDP端口10000。</p><h2 id=先搞定客户机>先搞定客户机</h2><p>客户机这边比较好搞定，所以先来介绍客户机的工作。主要的任务是用<code>WinPcap</code>抓取发往服务器的<code>TCP SYN</code>数据包，然后用UDP封装后发出去。过滤数据包的代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>pcap_compile</span>(fp, 
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>fcode, 
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;dst host 10.10.90.192 and tcp[tcpflags] &amp; (tcp-syn) != 0&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    netmask);
</span></span></code></pre></div><p>抓到数据包后的发送代码如下，因为做的是实验性的程序，所以就不要纠结性能和代码是不是优美了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>packet_handler</span>(u_char <span style=color:#f92672>*</span> user, 
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> pcap_pkthdr <span style=color:#f92672>*</span> header,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> u_char <span style=color:#f92672>*</span> data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	SOCKET sockClient <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>	SOCKADDR_IN addrServ;
</span></span><span style=display:flex><span>	addrServ.sin_addr.S_un.S_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>inet_addr</span>(<span style=color:#e6db74>&#34;10.10.90.192&#34;</span>);
</span></span><span style=display:flex><span>	addrServ.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>	addrServ.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* 这里+14和-14是当服务器使用tun时的数据，因为tun不需要mac层
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * 所以去掉，后面用tap的时候就可以去掉了
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sendto</span>(sockClient, (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)(data <span style=color:#f92672>+</span> <span style=color:#ae81ff>14</span>), 
</span></span><span style=display:flex><span>	        header<span style=color:#f92672>-&gt;</span>caplen <span style=color:#f92672>-</span> <span style=color:#ae81ff>14</span>, <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>	        (SOCKADDR<span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>addrServ, <span style=color:#66d9ef>sizeof</span>(SOCKADDR));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=服务器的tun尝试>服务器的TUN尝试</h2><p>服务器这边有点复杂，我首先想到的是用<code>tun</code>做，因为<code>tun</code>工作在第三层，逻辑上简单一些。当然好多代码其实是与<code>tap</code>通用的，打开<code>tun/tap</code>设备的代码是从上面那篇IBM的文档中模仿的。</p><p>首先是打开<code>tun/tap</code>设备的代码，主要是通过<code>dev</code>名字区分是<code>tap</code>还是<code>tun</code>，内核通过<code>IFF_TUN</code>和<code>IFF_TAP</code>标志来区分：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>tun_creat</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> dev, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> actual, <span style=color:#66d9ef>int</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ifreq ifr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> fd, err;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;/dev/net/tun&#34;</span>, O_RDWR)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>ifr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(ifr));
</span></span><span style=display:flex><span>    ifr.ifr_flags <span style=color:#f92672>=</span> IFF_NO_PI;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strncmp</span>(dev, <span style=color:#e6db74>&#34;tun&#34;</span>, <span style=color:#ae81ff>3</span>)) {
</span></span><span style=display:flex><span>        ifr.ifr_flags <span style=color:#f92672>|=</span> IFF_TUN;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strncmp</span>(dev, <span style=color:#e6db74>&#34;tap&#34;</span>, <span style=color:#ae81ff>3</span>)) {
</span></span><span style=display:flex><span>        ifr.ifr_flags <span style=color:#f92672>|=</span> IFF_TAP;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Device %s illegal</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>strlen</span>(dev) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((err <span style=color:#f92672>=</span> <span style=color:#a6e22e>ioctl</span>(fd, TUNSETIFF, (<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>ifr)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Cannot ioctl TUNSETIFF %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>close</span>(fd);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> err;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(actual, ifr.ifr_name, size);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> fd;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建完成后要将设备启动起来，相当于在shell中执行<code>ip link set xxx up</code>，通过<code>ioctl</code>设置标志来实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dev_bring_up</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> dev)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ifreq ifr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>ifr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> ifr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//先获取再设置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(sockfd, SIOCGIFFLAGS, <span style=color:#f92672>&amp;</span>ifr) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Error up %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ifr.ifr_ifru.ifru_flags <span style=color:#f92672>|=</span> IFF_UP;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(sockfd, SIOCSIFFLAGS, <span style=color:#f92672>&amp;</span>ifr) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Error up %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过调用这两个函数来启动一个<code>tun</code>设备：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tun;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> tun_name[IFNAMSIZ];
</span></span><span style=display:flex><span>    tun <span style=color:#f92672>=</span> <span style=color:#a6e22e>tun_creat</span>(<span style=color:#e6db74>&#34;tap10&#34;</span>, tun_name, <span style=color:#66d9ef>sizeof</span>(tun_name));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dev_bring_up</span>(tun_name);
</span></span></code></pre></div><p>创建后启动<code>tun</code>设备后就可以监听UDP端口，每次读到一个数据报就将数据全部写入到<code>tun</code>设备中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> sockaddr_in servaddr, cliaddr;
</span></span><span style=display:flex><span>    sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bzero</span>(<span style=color:#f92672>&amp;</span>servaddr, <span style=color:#66d9ef>sizeof</span>(servaddr));
</span></span><span style=display:flex><span>    servaddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>    servaddr.sin_addr.s_addr <span style=color:#f92672>=</span> <span style=color:#a6e22e>htonl</span>(INADDR_ANY);
</span></span><span style=display:flex><span>    servaddr.sin_port <span style=color:#f92672>=</span> <span style=color:#a6e22e>htons</span>(<span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bind</span>(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>servaddr, <span style=color:#66d9ef>sizeof</span>(servaddr));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> pkt[<span style=color:#ae81ff>1500</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> clilen <span style=color:#f92672>=</span> <span style=color:#66d9ef>sizeof</span>(cliaddr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> <span style=color:#a6e22e>recvfrom</span>(sockfd, pkt, <span style=color:#66d9ef>sizeof</span>(pkt), <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>                (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>cliaddr, <span style=color:#f92672>&amp;</span>clilen);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>calc_checksum</span>(pkt, n);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 下面这行在后面用tap的时候需要去掉注释。
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * mac是一个6字节的char数组，应该在之前申明。
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//memcpy(pkt, mac, 6);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>write</span>(tun, pkt, n);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>这里的<code>calc_checksum</code>函数是用来计算IP校验和和TCP校验和的，因为客户机很有可能开启了各种<code>offload</code>功能，将校验和的计算工作交给了网卡做处理，所以WinPcap抓到的数据包是没有经过校验和计算的，我们需要自己计算也确保协议栈接收数据包。</p><p>到此程序大致已经成型，运行后，通过Wireshark抓包发现<code>tun</code>虚拟设备已经有接收到的数据了，但是协议栈并没有按照预期的响应<code>TCP SYN ACK</code>数据包。其中的原理我也不是很明白，不过估计是因为<code>10.10.90.192</code>这个IP是设置在<code>eth0</code>网卡上的，所以虽然这个IP地址确实是本机网卡地址，但因为与接收的网卡不同所以协议栈不接收。</p><h2 id=使用tap>使用tap</h2><p>既然<code>tun</code>不行，那只能考虑<code>tap</code>，使用<code>tap</code>的好处是<code>tap</code>会虚拟出一块完整的以太网卡，而Linux内核支持虚拟网桥设备，如果把<code>eth0</code>和虚拟出来的<code>tap</code>都挂接到虚拟出的网桥<code>br0</code>上，把<code>10.10.90.192</code>这个IP分配给网桥<code>br0</code>，就可以让<code>tap</code>接收的数据包转发到<code>br0</code>上从而实现了目的IP与实际IP相同，这样协议栈就应该会接收这个数据包了。</p><p>首先要创建网桥，在shell中使用<code>brctl</code>命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brctl addbr br0                 <span style=color:#75715e>#创建网桥</span>
</span></span><span style=display:flex><span>brctl addif br0 eth0            <span style=color:#75715e>#将eth0先加入网桥</span>
</span></span><span style=display:flex><span>ifconfig br0 10.10.90.192 up    <span style=color:#75715e>#启动网桥并分配IP</span>
</span></span><span style=display:flex><span>ifconfig eth0 0.0.0.0           <span style=color:#75715e>#eth0现在不需要IP地址了</span>
</span></span></code></pre></div><p>然后在代码中，创建并启动完<code>tap10</code>后，将它加入到网桥中，这里偷个懒直接用<code>system</code>函数了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>    <span style=color:#a6e22e>system</span>(<span style=color:#e6db74>&#34;brctl addif br0 tap10&#34;</span>);
</span></span></code></pre></div><p>调整所有代码中的IP首部的偏移量。最后一个要解决的问题是要在把数据包写入到<code>tap</code>之前，修改以太网首部的目的MAC地址为网桥的MAC地址，不然目的MAC地址与网桥MAC地址不一致，网桥仍然不会接受这个包。获取网络设备MAC地址的方法是用<code>SIOCGIFHWADDR</code>调用<code>ioctl</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* mac应该是一个至少6字节的buffer */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>dev_get_mac</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> dev, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> mac)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> sockfd;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ifreq ifr;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((sockfd <span style=color:#f92672>=</span> <span style=color:#a6e22e>socket</span>(AF_INET, SOCK_DGRAM, <span style=color:#ae81ff>0</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>ifr, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span> ifr);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>strncpy</span>(ifr.ifr_name, dev, IFNAMSIZ);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ioctl</span>(sockfd, SIOCGIFHWADDR, <span style=color:#f92672>&amp;</span>ifr) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(stderr, <span style=color:#e6db74>&#34;Error get mac %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, dev);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memcpy</span>(mac, <span style=color:#f92672>&amp;</span>ifr.ifr_hwaddr.sa_data, <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close</span>(sockfd);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这次编译运行后，结果就如同我预期的那样，寝室电脑与服务器电脑已经可以顺利建立起TCP连接了，整个实验宣告成功。</p><p>最后说一下几个使用虚拟网桥的问题，在创建了<code>br0</code>之后，好多直接挂在<code>eth0</code>上的设置要变为<code>br0</code>，例如原来的默认路由表项是：</p><pre><code>default via 10.10.90.1 dev eth0
</code></pre><p>现在要修改为：</p><pre><code>default via 10.10.90.1 dev br0
</code></pre><p>原本我使用OpenVPN做nat时的设置是：</p><pre><code>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE
</code></pre><p>现在要修改为：</p><pre><code>iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o br0 -j MASQUERADE
</code></pre><p>因为原本的<code>eth0</code>已经没有地址了，<code>MASQUERADE</code>的结果就变成空的了，也就不会做nat了。</p></div></div><div id=post-footer class="post-footer main-content-wrap"><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2014/12/regular-expression/ data-tooltip=正则表达式学习总结 aria-label="下一篇: 正则表达式学习总结"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">下一篇</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2014/10/compile-wireshark/ data-tooltip=Windows下编译Wireshark aria-label="上一篇: Windows下编译Wireshark"><span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label=分享这个帖子><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label=发表评论><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label=回到顶部><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div><div id=gitalk><noscript>Please enable JavaScript to view the comments powered by Gitalk.</noscript></div><script src=https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js integrity="sha512-EcTCcXV46teiNwe0VcnM5A038tcY+BaQYO4nW6Gh2i7v4/HjBVg7xx3+JBLl9WofDds//INJAiEGAtdgr8PWyA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script type=text/javascript>(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("gitalk").innerHTML="Gitalk comments not available by default when the website is previewed locally.";return}new Gitalk({clientID:"2d9c9d837f8496107211",clientSecret:"5a474517d0eb6d5abdb90ab9a31c2ba94f4f43b2",repo:"core2duoe6420.github.io",owner:"core2duoe6420",admin:["core2duoe6420"],id:"5dd044a2443622d501c7878803f07933",...{distractionfreemode:!1,enablehotkey:!0,language:"zh-CN",pagerdirection:"first",perpage:10}}).render("gitalk")})()</script></div></article><footer id=footer class=main-content-wrap><span class=copyrights>&copy; 2023 Powered by Hugo with tranquilpeak. All Rights Reserved</span></footer></div><div id=bottom-bar class=post-bottom-bar data-behavior=4><div class=post-actions-wrap><nav><ul class="post-actions post-action-nav"><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2014/12/regular-expression/ data-tooltip=正则表达式学习总结 aria-label="下一篇: 正则表达式学习总结"><i class="fa fa-angle-left"></i>
<span class="hide-xs hide-sm text-small icon-ml">下一篇</span></a></li><li class=post-action><a class="post-action-btn btn btn--default tooltip--top" href=https://blog.hljin.net/2014/10/compile-wireshark/ data-tooltip=Windows下编译Wireshark aria-label="上一篇: Windows下编译Wireshark"><span class="hide-xs hide-sm text-small icon-mr">上一篇</span>
<i class="fa fa-angle-right"></i></a></li></ul></nav><ul class="post-actions post-action-share"><li class="post-action hide-lg hide-md hide-sm"><a class="post-action-btn btn btn--default btn-open-shareoptions" href=#btn-open-shareoptions aria-label=分享这个帖子><i class="fa fa-share-alt" aria-hidden=true></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#gitalk aria-label=发表评论><i class="fa fa-comment"></i></a></li><li class=post-action><a class="post-action-btn btn btn--default" href=#top aria-label=回到顶部><i class="fa fa-arrow-up" aria-hidden=true></i></a></li></ul></div></div></div><div id=about><div id=about-card><div id=about-btn-close><i class="fa fa-times"></i></div><img id=about-card-picture src=https://res.cloudinary.com/core2duoe6420/image/upload/v1643906248/DSC_5117_wviusa.jpg alt=作者的图片><h4 id=about-card-name>Alex King</h4><div id=about-card-bio>Observing without evaluating is the highest form of human intelligence</div><div id=about-card-job><i class="fa fa-briefcase"></i><br>Human</div><div id=about-card-location><i class="fa fa-map-marker-alt"></i><br>Shanghai</div></div></div><div id=cover style=background-image:url(https://res.cloudinary.com/core2duoe6420/image/upload/v1643905455/20220204002352_yqvhwd.jpg)></div><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/highlight.min.js integrity="sha512-z+/WWfyD5tccCukM4VvONpEtLmbAm5LDu7eKiyMQJ9m7OfPEDL7gENyDRL3Yfe8XAuGsS2fS4xSMnl6d30kqGQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha512-uURl+ZXMBrF4AwGaWmEetzrd+J5/8NRkWAvJx5sbPSSuOb0bZLqf+tOzniObO00BjHa/dD7gub9oCGMLPQHtQA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://blog.hljin.net/js/script-yqzy9wdlzix4lbbwdnzvwx3egsne77earqmn73v9uno8aupuph8wfguccut.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-gE8KAQyFIzV1C9+GZ8TKJHZS2s+n7EjNtC+IMRn1l5+WYJTHOODUM6JSjZhFhqXmc7bG8Av6XXpckA4tYhflnw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/apache.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-EWROca+bote+7Oaaar1F6y74iZj1r1F9rm/ly7o+/FwJopbBaWtsFDmaKoZDd3QiGU2pGacBirHJNivmGLYrow==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/go.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-GDVzAn0wpx1yVtQsRWmFc6PhJiLBPdUic+h4GWgljBh904O3JU10fk9EKNpVyIoPqkFn54rgL2QBG4BmUTMpiQ==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/http.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-UgZlma8NzkrDb/NWgmLIcTrH7i/CSnLLDRFqCSNF5NGPpjKmzyM25qcoXGOup8+cDakKyaiTDd7N4dyH4YT+IA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/less.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-lot9koe73sfXIrUvIPM/UEhuMciN56RPyBdOyZgfO53P2lkWyyXN7J+njcxIIBRV+nVDQeiWtiXg+bLAJZDTfg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/nginx.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-Zd3e7XxHP00TD0Imr0PIfeM0fl0v95kMWuhyAS3Wn1UTSXTkz0OhtRgBAr4JlmADRgiXr4x7lpeUdqaGN8xIog==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/puppet.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-qtqDO052iXMSP+5d/aE/jMtL9vIIGvONgTJziC2K/ZIB1yEGa55WVxGE9/08rSQ62EoDifS9SWVGZ7ihSLhzMA==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/scss.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-1NmkjnEDnwwwcu28KoQF8vs3oaPFokQHbmbtwGhFfeDsQZtVFI8zW2aE9O8yMYdpdyKV/5blE4pSWw4Z/Sv97w==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/stylus.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-B2wSfruPjr8EJL6IIzQr1eAuDwrsfIfccNf/LCEdxELCgC/S/ZMt/Uvk80aD79m7IqOqW+Sw8nbkvha20yZpzg==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/swift.min.js></script>
<script async crossorigin=anonymous defer integrity="sha512-28oDiQZGKUVN6wQ7PSLPNipOcmkCALXKwOi7bnkyFf8QiMZQxG9EQoy/iiNx6Zxj2cG2SbVa4dXKigQhu7GiFw==" src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/languages/yaml.min.js></script>
<script async crossorigin=anonymous defer src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<script>$(document).ready(function(){hljs.configure({classPrefix:"",useBR:!1}),$("pre.code-highlight > code, pre > code").each(function(e,t){$(this).hasClass("codeblock")||$(this).addClass("codeblock"),hljs.highlightBlock(t)})})</script></body></html>